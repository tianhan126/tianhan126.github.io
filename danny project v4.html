<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èƒ¡èåœå¡”é˜² - å¢å¼ºç‰ˆ</title>
    <style>
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
            margin: 0;
            padding: 20px;
            text-align: center;
            min-height: 100vh;
            color: #2e7d32;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 100, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        #game-title {
            color: #ff8f00;
            font-size: 2.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff8f00, #ffca28);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            z-index: 2;
        }
        
        #game-title::after {
            content: 'å¢å¼ºç‰ˆ';
            position: absolute;
            top: -10px;
            right: -40px;
            font-size: 0.4em;
            background: #e91e63;
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            transform: rotate(15deg);
        }
        
        #game-board {
            position: relative;
            width: 600px;
            height: 400px;
            background-color: #a5d6a7;
            border: 8px solid #81c784;
            border-radius: 15px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        #carrot {
            position: absolute;
            right: 20px;
            bottom: 50px;
            font-size: 50px;
            z-index: 10;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        .path {
            position: absolute;
            background-color: #8d6e63; /* åœŸåœ°è‰² */
            border-radius: 10px;
        }
        
        /* æ–°çš„èœ¿èœ’è·¯å¾„ */
        #path1 {
            width: 100px;
            height: 30px;
            left: 50px;
            top: 100px;
        }
        
        #path2 {
            width: 30px;
            height: 50px;
            left: 150px;
            top: 100px;
        }
        
        #path3 {
            width: 100px;
            height: 30px;
            left: 150px;
            top: 150px;
        }
        
        #path4 {
            width: 30px;
            height: 50px;
            left: 250px;
            top: 150px;
        }
        
        #path5 {
            width: 100px;
            height: 30px;
            left: 250px;
            top: 200px;
        }
        
        #path6 {
            width: 30px;
            height: 50px;
            left: 350px;
            top: 200px;
        }
        
        #path7 {
            width: 100px;
            height: 30px;
            left: 350px;
            top: 250px;
        }
        
        #path8 {
            width: 30px;
            height: 50px;
            left: 450px;
            top: 250px;
        }
        
        #path9 {
            width: 100px;
            height: 30px;
            left: 450px;
            top: 300px;
        }
        
        .tower {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            z-index: 5;
            transition: transform 0.2s;
            background: radial-gradient(circle at 30% 30%, #fff, #f1f8e9);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .tower:hover {
            transform: scale(1.1) rotate(5deg);
            z-index: 15;
        }
        
        .tower-level {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background-color: #ff8f00;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .pea-shooter {
            background-color: #4caf50;
            color: #2e7d32;
        }
        
        .pepper-thrower {
            background-color: #f44336;
            color: #b71c1c;
        }
        
        .onion-guard {
            background-color: #ffeb3b;
            color: #f57f17;
        }
        
        .corn-cannon {
            background-color: #fff59d;
            color: #f9a825;
        }
        
        .potato-mine {
            background-color: #8d6e63;
            color: #4e342e;
        }
        
        .garlic-tower {
            background-color: #f8bbd0;
            color: #ad1457;
        }
        
        .cabbage-pult {
            background-color: #dce775;
            color: #827717;
        }
        
        .melon-pult {
            background-color: #a5d6a7;
            color: #2e7d32;
        }
        
        .sunflower {
            background-color: #fff176;
            color: #f57f17;
        }
        
        /* æ–°ç‚®å°æ ·å¼ */
        .strawberry {
            background-color: #f44336;
            color: #c62828;
        }
        
        .pineapple {
            background-color: #ffeb3b;
            color: #f9a825;
        }
        
        .cactus {
            background-color: #4caf50;
            color: #2e7d32;
        }
        
        .mushroom {
            background-color: #7b1fa2;
            color: #4a148c;
        }
        
        .projectile {
            position: absolute;
            font-size: 20px;
            z-index: 4;
            transition: transform 0.1s linear;
        }
        
        .enemy {
            position: absolute;
            font-size: 30px;
            z-index: 3;
            transition: left 0.1s linear, top 0.1s linear;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
        }
        
        /* æ–°æ•Œäººæ ·å¼ */
        .dragon {
            font-size: 40px;
            color: #d32f2f;
            z-index: 4;
            animation: flame 1s infinite alternate;
        }
        
        @keyframes flame {
            0% { text-shadow: 0 0 5px #ff5722; }
            100% { text-shadow: 0 0 15px #ff5722, 0 0 25px #ff9800; }
        }
        
        .wizard-rabbit {
            font-size: 35px;
            color: #7b1fa2;
            animation: pulse 1.5s infinite;
        }
        
        .armored-beetle {
            font-size: 32px;
            color: #455a64;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .toxic-snail {
            font-size: 34px;
            color: #7cb342;
            animation: toxic-pulse 2s infinite;
        }
        
        /* å›°éš¾æ¨¡å¼ä¸“å±BOSS */
        .carrot-golem {
            font-size: 50px;
            color: #ff5722;
            z-index: 5;
            animation: golem-pulse 2s infinite;
        }
        
        @keyframes golem-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes toxic-pulse {
            0% { text-shadow: 0 0 5px #7cb342; }
            50% { text-shadow: 0 0 15px #7cb342; }
            100% { text-shadow: 0 0 5px #7cb342; }
        }
        
        #tower-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            max-width: 600px;
            padding: 15px;
            background-color: #f1f8e9;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .tower-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 25px;
            cursor: pointer;
            background-color: #c8e6c9;
            border: 3px solid #81c784;
            transition: transform 0.2s;
            position: relative;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .tower-option:hover {
            transform: scale(1.1);
            background-color: #a5d6a7;
        }
        
        .tower-cost {
            position: absolute;
            bottom: -15px;
            font-size: 12px;
            background-color: #ff8f00;
            color: white;
            padding: 2px 5px;
            border-radius: 10px;
            min-width: 30px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .selected {
            border-color: #ff8f00;
            box-shadow: 0 0 10px #ff8f00;
        }
        
        .locked {
            opacity: 0.5;
            cursor: not-allowed;
            position: relative;
        }
        
        .locked::after {
            content: "ğŸ”’";
            position: absolute;
            bottom: -20px;
            font-size: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: #d32f2f;
        }
        
        #game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
            background: linear-gradient(to right, #81c784, #66bb6a);
            padding: 10px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .game-button {
            background: linear-gradient(to bottom, #ff8f00, #f57c00);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 140px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }
        
        .game-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        
        .game-button:active {
            transform: translateY(1px);
        }
        
        .game-button:disabled {
            background: linear-gradient(to bottom, #bdbdbd, #9e9e9e);
            cursor: not-allowed;
            transform: none;
        }
        
        #restart-button {
            background: linear-gradient(to bottom, #d32f2f, #b71c1c);
        }
        
        #handbook-button {
            background: linear-gradient(to bottom, #2196f3, #1976d2);
        }
        
        #difficulty-button {
            background: linear-gradient(to bottom, #9c27b0, #7b1fa2);
        }
        
        #pause-button {
            background: linear-gradient(to bottom, #607d8b, #455a64);
        }
        
        #achievements-button {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
        }
        
        #message {
            margin-top: 10px;
            font-weight: bold;
            color: #d32f2f;
            min-height: 25px;
            padding: 8px 15px;
            background-color: #ffebee;
            border-radius: 20px;
            display: inline-block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .health-bar {
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #ccc;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #4caf50, #8bc34a);
            width: 100%;
            transition: width 0.3s ease;
        }
        
        /* å›¾é‰´æ ·å¼ */
        #handbook-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        #handbook-content {
            background-color: #f1f8e9;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .handbook-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .handbook-icon {
            font-size: 40px;
            margin-right: 15px;
            width: 60px;
            text-align: center;
        }
        
        .handbook-details {
            flex: 1;
        }
        
        .close-handbook {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f44336;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* éš¾åº¦é€‰æ‹©æ ·å¼ */
        #difficulty-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        #difficulty-content {
            background-color: #f1f8e9;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .difficulty-option {
            background-color: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .difficulty-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            background-color: #e3f2fd;
        }
        
        .difficulty-option.selected {
            background-color: #bbdefb;
            font-weight: bold;
            border-left: 5px solid #2196f3;
        }
        
        .difficulty-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #1976d2;
        }
        
        .difficulty-desc {
            font-size: 0.9em;
            color: #555;
        }
        
        /* æˆå°±æ ·å¼ */
        #achievements-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        #achievements-content {
            background-color: #f1f8e9;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .achievement-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        .achievement-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .achievement-icon {
            font-size: 30px;
            margin-right: 15px;
            width: 50px;
            text-align: center;
            color: #ff8f00;
        }
        
        .achievement-details {
            flex: 1;
        }
        
        .achievement-locked {
            opacity: 0.5;
            background-color: #f5f5f5;
        }
        
        .achievement-progress {
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }
        
        .achievement-reward {
            font-size: 0.9em;
            color: #4caf50;
            font-weight: bold;
            margin-top: 5px;
        }
        
        /* å‡çº§èœå•æ ·å¼ */
        #upgrade-menu {
            display: none;
            position: absolute;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 20;
            width: 200px;
            border: 2px solid #81c784;
        }
        
        .upgrade-option {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: bold;
        }
        
        .upgrade-option:hover {
            background-color: #e8f5e9;
            transform: translateX(5px);
        }
        
        .upgrade-cost {
            float: right;
            color: #ff8f00;
            font-weight: bold;
        }
        
        .upgrade-separator {
            border-top: 1px solid #ddd;
            margin: 8px 0;
        }
        
        /* ç‰¹æ®Šæ³¢æ¬¡æç¤º */
        .special-wave {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #ffeb3b, #ffc107);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #d32f2f;
            z-index: 30;
            animation: pulse 1s infinite;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        /* éŸ³æ•ˆæ§åˆ¶ */
        #sound-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(to bottom, #81c784, #66bb6a);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 50;
            transition: all 0.3s;
        }
        
        #sound-control:hover {
            transform: scale(1.1);
        }
        
        /* éŸ³é‡æ§åˆ¶ */
        #volume-control {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 25px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 50;
            display: none;
        }
        
        #volume-slider {
            width: 100px;
            height: 10px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #81c784, #4caf50);
            border-radius: 5px;
            outline: none;
        }
        
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff8f00;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* æ¸¸æˆèƒŒæ™¯è£…é¥° */
        .decoration {
            position: absolute;
            font-size: 30px;
            opacity: 0.2;
            z-index: 1;
            animation: float 15s infinite linear;
        }
        
        @keyframes float {
            0% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-20px) translateX(20px); }
            50% { transform: translateY(0) translateX(40px); }
            75% { transform: translateY(20px) translateX(20px); }
            100% { transform: translateY(0) translateX(0); }
        }
        
        /* æ–°ç‚®å°è§£é”é€šçŸ¥ */
        .unlock-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: slideIn 0.5s forwards, fadeOut 0.5s 2.5s forwards;
        }
        
        @keyframes slideIn {
            from { top: -100px; }
            to { top: 20px; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; visibility: hidden; }
        }
        
        /* æ¸¸æˆæ•™ç¨‹æ ·å¼ */
        #tutorial-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }
        
        #tutorial-content {
            background-color: #f1f8e9;
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .tutorial-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f44336;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-step {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tutorial-step:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .tutorial-icon {
            font-size: 30px;
            margin-right: 15px;
            float: left;
        }
        
        .tutorial-text {
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 id="game-title">ğŸ¥• èƒ¡èåœå¡”é˜² ğŸ¥•</h1>
        
        <div id="game-info">
            <div>ç”Ÿå‘½: <span id="lives">10</span></div>
            <div>é‡‘å¸: <span id="money">100</span></div>
            <div>æ³¢æ•°: <span id="wave">0</span>/<span id="max-wave">0</span></div>
            <div>éš¾åº¦: <span id="difficulty">æ™®é€š</span></div>
            <div>æˆå°±: <span id="achievement-count">0</span></div>
        </div>
        
        <div id="tower-selector">
            <div class="tower-option pea-shooter" title="è±Œè±†å°„æ‰‹ - èŠ±è´¹: 30" onclick="selectTower('pea-shooter')">
                ğŸŒ±
                <div class="tower-cost">30</div>
            </div>
            <div class="tower-option pepper-thrower" title="è¾£æ¤’æŠ•æ‰‹ - èŠ±è´¹: 50" onclick="selectTower('pepper-thrower')">
                ğŸŒ¶ï¸
                <div class="tower-cost">50</div>
            </div>
            <div class="tower-option onion-guard" title="æ´‹è‘±å®ˆå« - èŠ±è´¹: 40" onclick="selectTower('onion-guard')">
                ğŸ§…
                <div class="tower-cost">40</div>
            </div>
            <div class="tower-option corn-cannon" title="ç‰ç±³ç‚®å° - èŠ±è´¹: 70" onclick="selectTower('corn-cannon')">
                ğŸŒ½
                <div class="tower-cost">70</div>
            </div>
            <div class="tower-option potato-mine" title="åœŸè±†åœ°é›· - èŠ±è´¹: 60" onclick="selectTower('potato-mine')">
                ğŸ¥”
                <div class="tower-cost">60</div>
            </div>
            <div class="tower-option garlic-tower" title="å¤§è’œå¡” - èŠ±è´¹: 45" onclick="selectTower('garlic-tower')">
                ğŸ§„
                <div class="tower-cost">45</div>
            </div>
            <div class="tower-option cabbage-pult" title="å·å¿ƒèœæŠ•æ‰‹ - èŠ±è´¹: 55" onclick="selectTower('cabbage-pult')">
                ğŸ¥¬
                <div class="tower-cost">55</div>
            </div>
            <div class="tower-option melon-pult" title="è¥¿ç“œæŠ•æ‰‹ - èŠ±è´¹: 80" onclick="selectTower('melon-pult')">
                ğŸ‰
                <div class="tower-cost">80</div>
            </div>
            <div class="tower-option sunflower" title="å‘æ—¥è‘µ - èŠ±è´¹: 25" onclick="selectTower('sunflower')">
                ğŸŒ»
                <div class="tower-cost">25</div>
            </div>
            
            <!-- æˆå°±è§£é”çš„æ–°ç‚®å° -->
            <div class="tower-option strawberry locked" title="è‰è“å°„æ‰‹ - èŠ±è´¹: 65 (æˆå°±è§£é”)" onclick="selectLockedTower('strawberry', 'å»ºé€ 10åº§é˜²å¾¡å¡”')">
                ğŸ“
                <div class="tower-cost">65</div>
            </div>
            <div class="tower-option pineapple locked" title="è èç‚¸å¼¹ - èŠ±è´¹: 90 (æˆå°±è§£é”)" onclick="selectLockedTower('pineapple', 'ç´¯è®¡è·å¾—1000é‡‘å¸')">
                ğŸ
                <div class="tower-cost">90</div>
            </div>
            <div class="tower-option cactus locked" title="ä»™äººæŒå°„æ‰‹ - èŠ±è´¹: 70 (æˆå°±è§£é”)" onclick="selectLockedTower('cactus', 'å›°éš¾æ¨¡å¼å®Œæˆ15æ³¢')">
                ğŸŒµ
                <div class="tower-cost">70</div>
            </div>
            <div class="tower-option mushroom locked" title="è˜‘è‡äº‘ - èŠ±è´¹: 100 (æˆå°±è§£é”)" onclick="selectLockedTower('mushroom', 'å‡»è´¥100ä¸ªæ•Œäºº')">
                â˜ï¸
                <div class="tower-cost">100</div>
            </div>
        </div>
        
        <div id="game-board">
            <div id="carrot">ğŸ¥•</div>
            <!-- æ–°çš„èœ¿èœ’è·¯å¾„ -->
            <div class="path" id="path1"></div>
            <div class="path" id="path2"></div>
            <div class="path" id="path3"></div>
            <div class="path" id="path4"></div>
            <div class="path" id="path5"></div>
            <div class="path" id="path6"></div>
            <div class="path" id="path7"></div>
            <div class="path" id="path8"></div>
            <div class="path" id="path9"></div>
            
            <!-- èƒŒæ™¯è£…é¥° -->
            <div class="decoration" style="top: 50px; left: 100px;">ğŸŒ¿</div>
            <div class="decoration" style="top: 150px; left: 500px; animation-delay: -5s;">ğŸƒ</div>
            <div class="decoration" style="top: 300px; left: 200px; animation-delay: -10s;">ğŸŒ±</div>
        </div>
        
        <div id="controls">
            <button id="start-button" class="game-button" onclick="startWave()">å¼€å§‹æ³¢æ¬¡</button>
            <button id="pause-button" class="game-button" onclick="togglePause()">æš‚åœ</button>
            <button id="restart-button" class="game-button" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
            <button id="handbook-button" class="game-button" onclick="openHandbook()">å›¾é‰´</button>
            <button id="achievements-button" class="game-button" onclick="openAchievements()">æˆå°±</button>
            <button id="difficulty-button" class="game-button" onclick="openDifficultyModal()">éš¾åº¦</button>
        </div>
        
        <div id="message"></div>
    </div>

    <!-- æ¸¸æˆæ•™ç¨‹æ¨¡æ€æ¡† -->
    <div id="tutorial-modal">
        <div id="tutorial-content">
            <button class="tutorial-close" onclick="closeTutorial()">Ã—</button>
            <h2>æ¸¸æˆç©æ³•æŒ‡å—</h2>
            
            <div class="tutorial-step">
                <div class="tutorial-icon">ğŸ¯</div>
                <div class="tutorial-text">
                    <h3>æ¸¸æˆç›®æ ‡</h3>
                    <p>ä¿æŠ¤èƒ¡èåœğŸ¥•ä¸è¢«æ•Œäººåƒæ‰ï¼å»ºé€ é˜²å¾¡å¡”æ¥é˜»æ­¢æ•Œäººæ²¿ç€è·¯å¾„å‰è¿›ã€‚æ¯æ³¢æ•Œäººä¼šè¶Šæ¥è¶Šå¼ºï¼Œå°½å¯èƒ½åšæŒæ›´å¤šæ³¢æ¬¡ï¼</p>
                </div>
            </div>
            
            <div class="tutorial-step">
                <div class="tutorial-icon">ğŸ—ï¸</div>
                <div class="tutorial-text">
                    <h3>å»ºé€ é˜²å¾¡å¡”</h3>
                    <p>ç‚¹å‡»ä¸Šæ–¹çš„é˜²å¾¡å¡”å›¾æ ‡é€‰æ‹©ç±»å‹ï¼Œç„¶ååœ¨æ¸¸æˆåŒºåŸŸç‚¹å‡»æ”¾ç½®ã€‚æ¯ç§é˜²å¾¡å¡”æœ‰ä¸åŒçš„æ”»å‡»æ–¹å¼å’Œç‰¹æ€§ã€‚</p>
                    <p>å‘æ—¥è‘µğŸŒ»ä¸æ”»å‡»æ•Œäººï¼Œä½†ä¼šå®šæœŸäº§ç”Ÿé‡‘å¸ã€‚</p>
                </div>
            </div>
            
            <div class="tutorial-step">
                <div class="tutorial-icon">âš”ï¸</div>
                <div class="tutorial-text">
                    <h3>æ•Œäººç±»å‹</h3>
                    <p>æ•Œäººä¼šæ²¿ç€è·¯å¾„å‰è¿›ï¼Œä¸åŒç±»å‹æ•Œäººæœ‰ä¸åŒçš„ç‰¹æ€§ï¼š</p>
                    <p>ğŸ‡å…”å­é€Ÿåº¦å¿«ï¼ŒğŸŒèœ—ç‰›ç”Ÿå‘½å€¼é«˜ï¼ŒğŸ¦é¸Ÿæ˜¯é£è¡Œå•ä½åªèƒ½è¢«ç‰¹å®šå¡”æ”»å‡»ï¼ŒğŸ¦‚èå­å¯ä»¥æš‚æ—¶ç¦ç”¨é˜²å¾¡å¡”ã€‚</p>
                </div>
            </div>
            
            <div class="tutorial-step">
                <div class="tutorial-icon">â¬†ï¸</div>
                <div class="tutorial-text">
                    <h3>å‡çº§ç³»ç»Ÿ</h3>
                    <p>ç‚¹å‡»å·²æ”¾ç½®çš„é˜²å¾¡å¡”å¯ä»¥æ‰“å¼€å‡çº§èœå•ï¼Œå‡çº§å¯ä»¥æé«˜æ”»å‡»åŠ›ã€å°„ç¨‹ç­‰å±æ€§ã€‚</p>
                    <p>ä½ ä¹Ÿå¯ä»¥å‡ºå”®é˜²å¾¡å¡”è·å¾—éƒ¨åˆ†é‡‘å¸è¿”è¿˜ã€‚</p>
                </div>
            </div>
            
            <div class="tutorial-step">
                <div class="tutorial-icon">ğŸ†</div>
                <div class="tutorial-text">
                    <h3>æˆå°±ç³»ç»Ÿ</h3>
                    <p>å®Œæˆç‰¹å®šç›®æ ‡å¯ä»¥è§£é”æˆå°±ï¼Œæœ‰äº›æˆå°±è¿˜ä¼šè§£é”æ–°çš„é˜²å¾¡å¡”ç±»å‹ï¼</p>
                    <p>æŸ¥çœ‹"æˆå°±"æŒ‰é’®äº†è§£å…·ä½“è§£é”æ¡ä»¶ã€‚</p>
                </div>
            </div>
            
            <button class="game-button" onclick="closeTutorial()" style="width: 100%; margin-top: 20px;">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </div>

    <!-- å›¾é‰´æ¨¡æ€æ¡† -->
    <div id="handbook-modal">
        <div id="handbook-content">
            <button class="close-handbook" onclick="closeHandbook()">Ã—</button>
            <h2>æ¸¸æˆå›¾é‰´</h2>
            
            <div id="handbook-items">
                <!-- é˜²å¾¡å¡”å’Œæ•Œäººå°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
            </div>
        </div>
    </div>

    <!-- éš¾åº¦é€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="difficulty-modal">
        <div id="difficulty-content">
            <h2>é€‰æ‹©æ¸¸æˆéš¾åº¦</h2>
            
            <div class="difficulty-option" onclick="setDifficulty('easy')">
                <div class="difficulty-title">ç®€å•æ¨¡å¼</div>
                <div class="difficulty-desc">æ•Œäººè¾ƒå¼±ï¼Œé€‚åˆæ–°æ‰‹ç©å®¶</div>
            </div>
            
            <div class="difficulty-option selected" onclick="setDifficulty('normal')">
                <div class="difficulty-title">æ™®é€šæ¨¡å¼</div>
                <div class="difficulty-desc">æ ‡å‡†éš¾åº¦ï¼Œå¹³è¡¡çš„æ¸¸æˆä½“éªŒ</div>
            </div>
            
            <div class="difficulty-option" onclick="setDifficulty('hard')">
                <div class="difficulty-title">å›°éš¾æ¨¡å¼</div>
                <div class="difficulty-desc">æ•Œäººæ›´å¼ºï¼Œé€‚åˆæŒ‘æˆ˜è‡ªæˆ‘çš„ç©å®¶</div>
            </div>
            
            <button class="game-button" onclick="closeDifficultyModal()" style="width: 100%; margin-top: 20px;">ç¡®è®¤</button>
        </div>
    </div>

    <!-- æˆå°±æ¨¡æ€æ¡† -->
    <div id="achievements-modal">
        <div id="achievements-content">
            <h2>æ¸¸æˆæˆå°±</h2>
            
            <div id="achievements-list">
                <!-- æˆå°±å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
            </div>
            
            <button class="game-button" onclick="closeAchievements()" style="width: 100%; margin-top: 20px;">å…³é—­</button>
        </div>
    </div>

    <!-- å‡çº§èœå• -->
    <div id="upgrade-menu">
        <div id="upgrade-options">
            <!-- å‡çº§é€‰é¡¹å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
        </div>
        <div class="upgrade-separator"></div>
        <div class="upgrade-option" onclick="sellTower()">å‡ºå”® (<span id="sell-value">0</span>é‡‘å¸)</div>
    </div>

    <!-- éŸ³æ•ˆæ§åˆ¶æŒ‰é’® -->
    <button id="sound-control" onclick="toggleSound()">ğŸ”Š</button>
    
    <!-- éŸ³é‡æ§åˆ¶ -->
    <div id="volume-control">
        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.3">
    </div>

    <script>
        // æ¸¸æˆå˜é‡
        let selectedTowerType = null;
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let money = 100;
        let lives = 10;
        let wave = 0;
        let maxWave = 0;
        let gameRunning = false;
        let gamePaused = false;
        let towerElements = [];
        let enemyElements = [];
        let projectileElements = [];
        let difficulty = 'normal';
        let sunflowerInterval;
        let soundEnabled = true;
        let achievements = [];
        let selectedTowerForUpgrade = null;
        let unlockedTowers = {
            'strawberry': false,
            'pineapple': false,
            'cactus': false,
            'mushroom': false
        };
        
        // éŸ³æ•ˆ
        const sounds = {
            placeTower: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3'),
            enemyDefeated: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3'),
            towerAttack: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-short-laser-gun-shot-1670.mp3'),
            gameOver: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-lose-2027.mp3'),
            waveStart: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3'),
            upgrade: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3'),
            click: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3'),
            sell: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-cash-register-printing-receipt-2583.mp3'),
            unlock: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-game-level-completed-2059.mp3')
        };
        
        // åˆå§‹åŒ–éŸ³æ•ˆ
        Object.values(sounds).forEach(sound => {
            sound.volume = 0.3;
        });
        
        // éš¾åº¦è®¾ç½®
        const difficultySettings = {
            easy: { 
                enemyHealthMultiplier: 0.8,
                enemySpeedMultiplier: 0.9,
                startingMoney: 150,
                startingLives: 15,
                rewardMultiplier: 1.2,
                towerCostMultiplier: 0.9,
                upgradeCostMultiplier: 0.8
            },
            normal: { 
                enemyHealthMultiplier: 1,
                enemySpeedMultiplier: 1,
                startingMoney: 100,
                startingLives: 10,
                rewardMultiplier: 1,
                towerCostMultiplier: 1,
                upgradeCostMultiplier: 1
            },
            hard: { 
                enemyHealthMultiplier: 1.3,
                enemySpeedMultiplier: 1.2,
                startingMoney: 70,
                startingLives: 7,
                rewardMultiplier: 0.8,
                towerCostMultiplier: 1.1,
                upgradeCostMultiplier: 1.2
            }
        };
        
        // å¡”é˜²æ•°æ®
        const towerData = {
            'pea-shooter': { 
                name: 'è±Œè±†å°„æ‰‹',
                cost: 30, 
                damage: 10, 
                range: 150, 
                cooldown: 1000, 
                emoji: 'ğŸŒ±',
                damagePerLevel: 2,
                rangePerLevel: 10,
                upgradeCost: 20
            },
            'pepper-thrower': { 
                name: 'è¾£æ¤’æŠ•æ‰‹',
                cost: 50, 
                damage: 25, 
                range: 120, 
                cooldown: 1500, 
                emoji: 'ğŸŒ¶ï¸',
                damagePerLevel: 5,
                rangePerLevel: 5,
                upgradeCost: 30
            },
            'onion-guard': { 
                name: 'æ´‹è‘±å®ˆå«',
                cost: 40, 
                damage: 5, 
                range: 100, 
                cooldown: 800, 
                emoji: 'ğŸ§…',
                damagePerLevel: 1,
                rangePerLevel: 5,
                upgradeCost: 25
            },
            'corn-cannon': { 
                name: 'ç‰ç±³ç‚®å°',
                cost: 70, 
                damage: 40, 
                range: 180, 
                cooldown: 2000, 
                emoji: 'ğŸŒ½',
                damagePerLevel: 8,
                rangePerLevel: 10,
                upgradeCost: 40
            },
            'potato-mine': { 
                name: 'åœŸè±†åœ°é›·',
                cost: 60, 
                damage: 100, 
                range: 0, 
                cooldown: 0, 
                emoji: 'ğŸ¥”', 
                isMine: true,
                damagePerLevel: 20,
                upgradeCost: 35
            },
            'garlic-tower': { 
                name: 'å¤§è’œå¡”',
                cost: 45, 
                damage: 8, 
                range: 90, 
                cooldown: 1200, 
                emoji: 'ğŸ§„', 
                stunDuration: 500,
                damagePerLevel: 2,
                rangePerLevel: 5,
                upgradeCost: 25,
                stunPerLevel: 100
            },
            'cabbage-pult': { 
                name: 'å·å¿ƒèœæŠ•æ‰‹',
                cost: 55, 
                damage: 15, 
                range: 140, 
                cooldown: 1500, 
                emoji: 'ğŸ¥¬', 
                critChance: 0.3,
                damagePerLevel: 3,
                rangePerLevel: 5,
                upgradeCost: 30,
                critPerLevel: 0.05
            },
            'melon-pult': { 
                name: 'è¥¿ç“œæŠ•æ‰‹',
                cost: 80, 
                damage: 35, 
                range: 160, 
                cooldown: 2000, 
                emoji: 'ğŸ‰', 
                splashRadius: 50,
                damagePerLevel: 7,
                rangePerLevel: 5,
                upgradeCost: 45,
                splashPerLevel: 5
            },
            'sunflower': { 
                name: 'å‘æ—¥è‘µ',
                cost: 25, 
                damage: 0, 
                range: 0, 
                cooldown: 0, 
                emoji: 'ğŸŒ»', 
                income: 5, 
                incomeInterval: 10000,
                incomePerLevel: 1,
                upgradeCost: 15
            },
            // æ–°ç‚®å°æ•°æ®
            'strawberry': { 
                name: 'è‰è“å°„æ‰‹',
                cost: 65, 
                damage: 18, 
                range: 140, 
                cooldown: 1200, 
                emoji: 'ğŸ“',
                damagePerLevel: 4,
                rangePerLevel: 10,
                upgradeCost: 35,
                poisonChance: 0.4,
                poisonDuration: 3000,
                poisonDamage: 3,
                poisonPerLevel: 0.05
            },
            'pineapple': { 
                name: 'è èç‚¸å¼¹',
                cost: 90, 
                damage: 60, 
                range: 130, 
                cooldown: 2500, 
                emoji: 'ğŸ',
                damagePerLevel: 12,
                rangePerLevel: 5,
                upgradeCost: 50,
                splashRadius: 70,
                splashPerLevel: 5
            },
            'cactus': { 
                name: 'ä»™äººæŒå°„æ‰‹',
                cost: 70, 
                damage: 15, 
                range: 180, 
                cooldown: 700, 
                emoji: 'ğŸŒµ',
                damagePerLevel: 3,
                rangePerLevel: 10,
                upgradeCost: 40,
                pierceChance: 0.3,
                piercePerLevel: 0.05
            },
            'mushroom': { 
                name: 'è˜‘è‡äº‘',
                cost: 100, 
                damage: 80, 
                range: 200, 
                cooldown: 3000, 
                emoji: 'â˜ï¸',
                damagePerLevel: 15,
                rangePerLevel: 10,
                upgradeCost: 60,
                splashRadius: 100,
                slowEffect: 0.5,
                slowDuration: 3000,
                slowPerLevel: 0.05
            }
        };
        
        // æ•Œäººæ•°æ®
        const enemyData = {
            'ğŸ›': { name: 'èšœè™«', health: 30, speed: 1, reward: 5, desc: 'åŸºç¡€æ•Œäººï¼Œæ•°é‡å¤š' },
            'ğŸ‡': { name: 'å…”å­', health: 50, speed: 2, reward: 10, desc: 'ç§»åŠ¨é€Ÿåº¦å¿«' },
            'ğŸ€': { name: 'è€é¼ ', health: 80, speed: 0.8, reward: 15, desc: 'ç”Ÿå‘½å€¼è¾ƒé«˜' },
            'ğŸ¦': { name: 'é¸Ÿ', health: 60, speed: 1.5, reward: 12, desc: 'é£è¡Œå•ä½ï¼Œåªèƒ½è¢«ç‰¹å®šå¡”æ”»å‡»' },
            'ğŸŒ': { name: 'èœ—ç‰›', health: 120, speed: 0.5, reward: 20, desc: 'ç”Ÿå‘½å€¼å¾ˆé«˜' },
            'ğŸ¦—': { name: 'è—è™«', health: 40, speed: 2.5, reward: 8, desc: 'ç§»åŠ¨é€Ÿåº¦æå¿«' },
            'ğŸ¦': { name: 'èœ¥èœ´', health: 70, speed: 1.2, reward: 14, desc: 'æœ‰å‡ ç‡é—ªé¿æ”»å‡»' },
            'ğŸ': { name: 'èœœèœ‚', health: 45, speed: 1.8, reward: 10, desc: 'é£è¡Œå•ä½ï¼Œåªèƒ½è¢«ç‰¹å®šå¡”æ”»å‡»' },
            'ğŸœ': { name: 'èš‚èš', health: 25, speed: 1.3, reward: 5, desc: 'æˆç¾¤å‡ºç°' },
            'ğŸ¦‚': { name: 'èå­', health: 90, speed: 0.7, reward: 18, desc: 'å¯ä»¥æš‚æ—¶ç¦ç”¨é˜²å¾¡å¡”' },
            'ğŸ²': { name: 'å·¨é¾™', health: 200, speed: 1.2, reward: 50, desc: 'é£è¡Œå•ä½ï¼Œå¯¹é˜²å¾¡å¡”é€ æˆé¢å¤–ä¼¤å®³' },
            'ğŸ§™': { name: 'é­”æ³•å…”', health: 100, speed: 0.8, reward: 25, desc: 'å¬å”¤å°å…”åˆ†èº«ï¼Œé™ä½é™„è¿‘é˜²å¾¡å¡”æ”»å‡»é€Ÿåº¦' },
            'ğŸ›¡ï¸': { name: 'è£…ç”²è™«', health: 150, speed: 0.6, reward: 30, desc: 'é«˜é˜²å¾¡ï¼Œå‡å°‘å—åˆ°çš„ä¼¤å®³' },
            'ğŸ§ª': { name: 'æ¯’æ¶²èœ—ç‰›', health: 90, speed: 0.4, reward: 20, desc: 'ç•™ä¸‹æ¯’æ¶²è·¯å¾„ï¼Œå¯¹ç»è¿‡çš„æ•Œäººæä¾›å¢ç›Š' },
            'ğŸ¥•': { name: 'èƒ¡èåœå·¨äºº', health: 500, speed: 0.3, reward: 100, desc: 'å…ç–«å‡é€Ÿå’Œçœ©æ™•ï¼Œå¯¹èƒ¡èåœé€ æˆ3å€ä¼¤å®³' }
        };
        
        // æ–°çš„æ•Œäººè¡Œè¿›è·¯å¾„ï¼ˆæ›´èœ¿èœ’ï¼‰
        const path = [
            { x: 50, y: 115 },     // èµ·ç‚¹
            { x: 150, y: 115 },    // ç¬¬ä¸€æ®µ
            { x: 150, y: 165 },    // ç¬¬ä¸€ä¸ªè½¬å¼¯
            { x: 250, y: 165 },    // ç¬¬äºŒæ®µ
            { x: 250, y: 215 },    // ç¬¬äºŒä¸ªè½¬å¼¯
            { x: 350, y: 215 },    // ç¬¬ä¸‰æ®µ
            { x: 350, y: 265 },    // ç¬¬ä¸‰ä¸ªè½¬å¼¯
            { x: 450, y: 265 },    // ç¬¬å››æ®µ
            { x: 450, y: 315 },    // ç¬¬å››ä¸ªè½¬å¼¯
            { x: 550, y: 315 }     // ç»ˆç‚¹ï¼ˆèƒ¡èåœä½ç½®ï¼‰
        ];
        
        // æˆå°±ç³»ç»Ÿ
        const achievementData = [
            { id: 'first_blood', name: 'ç¬¬ä¸€æ»´è¡€', description: 'å‡»è´¥ç¬¬ä¸€ä¸ªæ•Œäºº', icon: 'ğŸ©¸', condition: (game) => game.enemiesDefeated >= 1, unlockTower: null },
            { id: 'tower_master', name: 'å¡”é˜²å¤§å¸ˆ', description: 'å»ºé€ 10åº§é˜²å¾¡å¡”', icon: 'ğŸ°', condition: (game) => game.towersBuilt >= 10, unlockTower: 'strawberry' },
            { id: 'wave_10', name: 'åæ³¢æŒ‘æˆ˜', description: 'å®Œæˆç¬¬10æ³¢', icon: 'ğŸ”Ÿ', condition: (game) => game.wave >= 10, unlockTower: null },
            { id: 'wave_20', name: 'äºŒåæ³¢æŒ‘æˆ˜', description: 'å®Œæˆç¬¬20æ³¢', icon: '2ï¸âƒ£0ï¸âƒ£', condition: (game) => game.wave >= 20, unlockTower: null },
            { id: 'rich', name: 'å¯Œå¯æ•Œå›½', description: 'ç´¯è®¡è·å¾—1000é‡‘å¸', icon: 'ğŸ’°', condition: (game) => game.totalMoneyEarned >= 1000, unlockTower: 'pineapple' },
            { id: 'sunflower_field', name: 'å‘æ—¥è‘µç”°', description: 'å»ºé€ 5ä¸ªå‘æ—¥è‘µ', icon: 'ğŸŒ»', condition: (game) => game.sunflowersBuilt >= 5, unlockTower: null },
            { id: 'perfectionist', name: 'å®Œç¾ä¸»ä¹‰è€…', description: 'å®Œæˆä¸€æ³¢è€Œä¸æŸå¤±ç”Ÿå‘½', icon: 'ğŸ’¯', condition: (game) => game.perfectWaves >= 1, unlockTower: null },
            { id: 'speed_runner', name: 'é€Ÿé€šç©å®¶', description: 'åœ¨5åˆ†é’Ÿå†…å®Œæˆ10æ³¢', icon: 'â±ï¸', condition: (game) => game.wave >= 10 && game.gameTime < 300000, unlockTower: null },
            { id: 'hard_mode', name: 'ç¡¬æ ¸ç©å®¶', description: 'åœ¨å›°éš¾æ¨¡å¼ä¸‹å®Œæˆ15æ³¢', icon: 'ğŸ’€', condition: (game) => game.wave >= 15 && game.difficulty === 'hard', unlockTower: 'cactus' },
            { id: 'upgrade_king', name: 'å‡çº§ä¹‹ç‹', description: 'å‡çº§10æ¬¡é˜²å¾¡å¡”', icon: 'â¬†ï¸', condition: (game) => game.towersUpgraded >= 10, unlockTower: null },
            { id: 'enemy_slayer', name: 'æ•Œäººæ€æ‰‹', description: 'å‡»è´¥100ä¸ªæ•Œäºº', icon: 'âš”ï¸', condition: (game) => game.enemiesDefeated >= 100, unlockTower: 'mushroom' },
            { id: 'boss_slayer', name: 'BOSSæ€æ‰‹', description: 'å‡»è´¥èƒ¡èåœå·¨äºº', icon: 'ğŸ¥•', condition: (game) => game.bossesDefeated >= 1, unlockTower: null }
        ];
        
        // æ¸¸æˆç»Ÿè®¡
        const gameStats = {
            enemiesDefeated: 0,
            towersBuilt: 0,
            totalMoneyEarned: 100,
            sunflowersBuilt: 0,
            perfectWaves: 0,
            gameTime: 0,
            difficulty: 'normal',
            towersUpgraded: 0,
            achievementsUnlocked: 0,
            bossesDefeated: 0
        };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // æ¸…é™¤æ‰€æœ‰æ¸¸æˆå…ƒç´ 
            clearGameElements();
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            selectedTowerType = null;
            towers = [];
            enemies = [];
            projectiles = [];
            money = difficultySettings[difficulty].startingMoney;
            lives = difficultySettings[difficulty].startingLives;
            wave = 0;
            gameRunning = false;
            gamePaused = false;
            gameStats.gameTime = 0;
            
            // é‡ç½®æ¸¸æˆç»Ÿè®¡
            gameStats.enemiesDefeated = 0;
            gameStats.towersBuilt = 0;
            gameStats.totalMoneyEarned = difficultySettings[difficulty].startingMoney;
            gameStats.sunflowersBuilt = 0;
            gameStats.perfectWaves = 0;
            gameStats.towersUpgraded = 0;
            gameStats.difficulty = difficulty;
            gameStats.achievementsUnlocked = 0;
            gameStats.bossesDefeated = 0;
            achievements = [];
            
            // é‡ç½®è§£é”çš„ç‚®å°
            unlockedTowers = {
                'strawberry': false,
                'pineapple': false,
                'cactus': false,
                'mushroom': false
            };
            updateTowerSelector();
            
            // æ¸…é™¤å‘æ—¥è‘µæ”¶å…¥é—´éš”
            if (sunflowerInterval) {
                clearInterval(sunflowerInterval);
                sunflowerInterval = null;
            }
            
            // æ›´æ–°UI
            updateGameInfo();
            document.getElementById('start-button').disabled = false;
            document.getElementById('pause-button').textContent = 'æš‚åœ';
            document.querySelectorAll('.tower-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            showMessage("æ¸¸æˆå·²å‡†å¤‡å°±ç»ª! é€‰æ‹©é˜²å¾¡å¡”å¼€å§‹æ¸¸æˆ");
            
            // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
            playSound('click');
        }
        
        // æ¸…é™¤æ‰€æœ‰æ¸¸æˆå…ƒç´ 
        function clearGameElements() {
            // æ¸…é™¤æ‰€æœ‰å¡”
            towerElements.forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
            towerElements = [];
            
            // æ¸…é™¤æ‰€æœ‰æ•Œäºº
            enemyElements.forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
            enemyElements = [];
            
            // æ¸…é™¤æ‰€æœ‰æŠ•å°„ç‰©
            projectileElements.forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
            projectileElements = [];
            
            // æ¸…é™¤æ¸¸æˆå¾ªç¯
            if (window.gameLoop) {
                clearInterval(window.gameLoop);
                window.gameLoop = null;
            }
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            if (confirm("ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚")) {
                playSound('click');
                initGame();
            }
        }
        
        // æ‰“å¼€å›¾é‰´
        function openHandbook() {
            const container = document.getElementById('handbook-items');
            container.innerHTML = '';
            
            // æ·»åŠ é˜²å¾¡å¡”ä¿¡æ¯
            Object.keys(towerData).forEach(type => {
                const tower = towerData[type];
                const item = document.createElement('div');
                item.className = 'handbook-item';
                
                item.innerHTML = `
                    <div class="handbook-icon">${tower.emoji}</div>
                    <div class="handbook-details">
                        <h4>${tower.name}</h4>
                        <p><strong>èŠ±è´¹:</strong> ${getTowerCost(type)}é‡‘å¸</p>
                        <p><strong>ä¼¤å®³:</strong> ${tower.damage} (+${tower.damagePerLevel}/çº§)</p>
                        ${tower.range ? `<p><strong>å°„ç¨‹:</strong> ${tower.range} (+${tower.rangePerLevel}/çº§)</p>` : ''}
                        <p><strong>ç‰¹æ€§:</strong> ${getTowerDescription(type)}</p>
                    </div>
                `;
                
                container.appendChild(item);
            });
            
            // æ·»åŠ æ•Œäººä¿¡æ¯
            Object.keys(enemyData).forEach(type => {
                const enemy = enemyData[type];
                const item = document.createElement('div');
                item.className = 'handbook-item';
                
                item.innerHTML = `
                    <div class="handbook-icon">${type}</div>
                    <div class="handbook-details">
                        <h4>${enemy.name}</h4>
                        <p><strong>ç”Ÿå‘½å€¼:</strong> ${enemy.health} (éšæ³¢æ•°å¢åŠ )</p>
                        <p><strong>é€Ÿåº¦:</strong> ${enemy.speed}</p>
                        <p><strong>å¥–åŠ±:</strong> ${enemy.reward}é‡‘å¸</p>
                        <p><strong>ç‰¹æ€§:</strong> ${enemy.desc}</p>
                    </div>
                `;
                
                container.appendChild(item);
            });
            
            document.getElementById('handbook-modal').style.display = 'flex';
            playSound('click');
        }
        
        // è·å–é˜²å¾¡å¡”æè¿°
        function getTowerDescription(type) {
            const tower = towerData[type];
            let desc = '';
            
            if (type === 'pea-shooter') desc = 'åŸºç¡€æ”»å‡»å¡”ï¼Œå‘å°„è±Œè±†è¿›è¡Œç›´çº¿æ”»å‡»';
            else if (type === 'pepper-thrower') desc = 'é«˜ä¼¤å®³ä½†æ”»å‡»é€Ÿåº¦æ…¢';
            else if (type === 'onion-guard') desc = 'æ”»å‡»é€Ÿåº¦å¿«ä½†ä¼¤å®³ä½';
            else if (type === 'corn-cannon') desc = 'è¶…è¿œå°„ç¨‹ä½†æ”»å‡»é€Ÿåº¦å¾ˆæ…¢';
            else if (type === 'potato-mine') desc = 'æ”¾ç½®å3ç§’æ¿€æ´»ï¼Œæ•Œäººæ¥è¿‘æ—¶çˆ†ç‚¸';
            else if (type === 'garlic-tower') desc = 'æœ‰å‡ ç‡çœ©æ™•æ•Œäºº';
            else if (type === 'cabbage-pult') desc = 'æœ‰å‡ ç‡é€ æˆæš´å‡»ä¼¤å®³';
            else if (type === 'melon-pult') desc = 'é€ æˆèŒƒå›´æº…å°„ä¼¤å®³';
            else if (type === 'sunflower') desc = 'æ¯10ç§’äº§ç”Ÿ5é‡‘å¸ (+1/çº§)';
            else if (type === 'strawberry') desc = 'å‘å°„è‰è“ï¼Œæœ‰å‡ ç‡ä½¿æ•Œäººä¸­æ¯’ï¼ˆæŒç»­ä¼¤å®³ï¼‰';
            else if (type === 'pineapple') desc = 'æŠ•æ·è èé€ æˆå¤§èŒƒå›´çˆ†ç‚¸ä¼¤å®³';
            else if (type === 'cactus') desc = 'å¯ä»¥æ”»å‡»é£è¡Œå’Œåœ°é¢å•ä½ï¼Œæœ‰å‡ ç‡ç©¿é€æ•Œäºº';
            else if (type === 'mushroom') desc = 'å‘å°„è˜‘è‡äº‘ï¼Œé€ æˆå·¨å¤§èŒƒå›´ä¼¤å®³å¹¶å‡é€Ÿæ•Œäºº';
            
            return desc;
        }
        
        // å…³é—­å›¾é‰´
        function closeHandbook() {
            document.getElementById('handbook-modal').style.display = 'none';
            playSound('click');
        }
        
        // æ‰“å¼€æˆå°±
        function openAchievements() {
            const list = document.getElementById('achievements-list');
            list.innerHTML = '';
            
            achievementData.forEach(ach => {
                const achieved = achievements.includes(ach.id);
                const progress = ach.condition(gameStats);
                
                const item = document.createElement('div');
                item.className = `achievement-item ${achieved ? '' : 'achievement-locked'}`;
                
                let rewardText = '';
                if (ach.unlockTower) {
                    rewardText = `<div class="achievement-reward">è§£é”: ${towerData[ach.unlockTower].name} ${towerData[ach.unlockTower].emoji}</div>`;
                }
                
                item.innerHTML = `
                    <div class="achievement-icon">${ach.icon}</div>
                    <div class="achievement-details">
                        <h4>${ach.name}</h4>
                        <p>${ach.description}</p>
                        ${rewardText}
                        ${!achieved && typeof progress === 'number' ? 
                            `<div class="achievement-progress">è¿›åº¦: ${Math.min(100, Math.round(progress * 100))}%</div>` : ''}
                    </div>
                `;
                
                list.appendChild(item);
            });
            
            document.getElementById('achievements-modal').style.display = 'flex';
            playSound('click');
        }
        
        // å…³é—­æˆå°±
        function closeAchievements() {
            document.getElementById('achievements-modal').style.display = 'none';
            playSound('click');
        }
        
        // æ‰“å¼€éš¾åº¦é€‰æ‹©
        function openDifficultyModal() {
            document.getElementById('difficulty-modal').style.display = 'flex';
            // æ›´æ–°å½“å‰é€‰æ‹©çš„éš¾åº¦
            document.querySelectorAll('.difficulty-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector(`.difficulty-option:nth-child(${
                difficulty === 'easy' ? 1 : difficulty === 'normal' ? 2 : 3
            })`).classList.add('selected');
            playSound('click');
        }
        
        // å…³é—­éš¾åº¦é€‰æ‹©
        function closeDifficultyModal() {
            document.getElementById('difficulty-modal').style.display = 'none';
            playSound('click');
        }
        
        // å…³é—­æ•™ç¨‹
        function closeTutorial() {
            document.getElementById('tutorial-modal').style.display = 'none';
            playSound('click');
        }
        
        // è®¾ç½®éš¾åº¦
        function setDifficulty(level) {
            difficulty = level;
            document.getElementById('difficulty').textContent = 
                level === 'easy' ? 'ç®€å•' : level === 'normal' ? 'æ™®é€š' : 'å›°éš¾';
            gameStats.difficulty = level;
            closeDifficultyModal();
            initGame();
        }
        
        // é€‰æ‹©é˜²å¾¡å¡”
        function selectTower(type) {
            selectedTowerType = type;
            document.querySelectorAll('.tower-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector(`.tower-option.${type}`).classList.add('selected');
            showMessage(`å·²é€‰æ‹©: ${towerData[type].name} (èŠ±è´¹: ${getTowerCost(type)})`);
            playSound('click');
        }
        
        // é€‰æ‹©é”å®šçš„é˜²å¾¡å¡”
        function selectLockedTower(type, condition) {
            showMessage(`éœ€è¦è§£é”: ${condition}`);
            playSound('click');
        }
        
        // æ›´æ–°ç‚®å°é€‰æ‹©å™¨æ˜¾ç¤º
        function updateTowerSelector() {
            document.querySelectorAll('.tower-option').forEach(opt => {
                const type = opt.classList[1];
                if (unlockedTowers[type]) {
                    opt.classList.remove('locked');
                    opt.onclick = function() { selectTower(type); };
                    opt.title = `${towerData[type].name} - èŠ±è´¹: ${getTowerCost(type)}`;
                }
            });
        }
        
        // è·å–é˜²å¾¡å¡”æˆæœ¬ï¼ˆè€ƒè™‘éš¾åº¦ï¼‰
        function getTowerCost(type) {
            return Math.round(towerData[type].cost * difficultySettings[difficulty].towerCostMultiplier);
        }
        
        // è·å–å‡çº§æˆæœ¬ï¼ˆè€ƒè™‘éš¾åº¦ï¼‰
        function getUpgradeCost(type, level) {
            return Math.round(towerData[type].upgradeCost * difficultySettings[difficulty].upgradeCostMultiplier * level);
        }
        
        // è·å–é˜²å¾¡å¡”åç§°
        function getTowerName(type) {
            return towerData[type]?.name || type;
        }
        
        // æ”¾ç½®é˜²å¾¡å¡”
        document.getElementById('game-board').addEventListener('click', function(e) {
            if (!selectedTowerType || gameRunning || gamePaused) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨è·¯å¾„ä¸Š
            if (isOnPath(x, y)) {
                showMessage("ä¸èƒ½åœ¨è·¯å¾„ä¸Šæ”¾ç½®é˜²å¾¡å¡”!");
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„é‡‘å¸
            const cost = getTowerCost(selectedTowerType);
            if (money < cost) {
                showMessage("é‡‘å¸ä¸è¶³!");
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å¡”é‡å 
            for (const tower of towers) {
                const dx = tower.x - x;
                const dy = tower.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 40) {
                    showMessage("è¿™é‡Œå·²ç»æœ‰ä¸€ä¸ªé˜²å¾¡å¡”äº†!");
                    return;
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦ç¦»èƒ¡èåœå¤ªè¿‘
            const carrotRect = document.getElementById('carrot').getBoundingClientRect();
            const carrotX = carrotRect.left - rect.left + carrotRect.width / 2;
            const carrotY = carrotRect.top - rect.top + carrotRect.height / 2;
            const distanceToCarrot = Math.sqrt(Math.pow(x - carrotX, 2) + Math.pow(y - carrotY, 2));
            if (distanceToCarrot < 60) {
                showMessage("ä¸èƒ½æŠŠé˜²å¾¡å¡”æ”¾åœ¨èƒ¡èåœæ—è¾¹!");
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦ç¦»è¾¹ç•Œå¤ªè¿‘
            if (x < 30 || x > 570 || y < 30 || y > 370) {
                showMessage("ä¸èƒ½æŠŠé˜²å¾¡å¡”æ”¾åœ¨å¤ªé è¿‘è¾¹ç¼˜çš„ä½ç½®!");
                return;
            }
            
            // åˆ›å»ºé˜²å¾¡å¡”
            const tower = {
                type: selectedTowerType,
                x: x,
                y: y,
                level: 1,
                cooldown: 0,
                emoji: towerData[selectedTowerType].emoji,
                isMine: towerData[selectedTowerType].isMine || false,
                mineActive: false,
                stunDuration: towerData[selectedTowerType].stunDuration || 0,
                critChance: towerData[selectedTowerType].critChance || 0,
                splashRadius: towerData[selectedTowerType].splashRadius || 0,
                income: towerData[selectedTowerType].income || 0,
                incomeInterval: towerData[selectedTowerType].incomeInterval || 0,
                lastIncomeTime: 0,
                disableTimer: 0,
                damage: towerData[selectedTowerType].damage,
                range: towerData[selectedTowerType].range,
                // æ–°ç‚®å°ç‰¹æœ‰å±æ€§
                poisonChance: towerData[selectedTowerType].poisonChance || 0,
                poisonDuration: towerData[selectedTowerType].poisonDuration || 0,
                poisonDamage: towerData[selectedTowerType].poisonDamage || 0,
                pierceChance: towerData[selectedTowerType].pierceChance || 0,
                slowEffect: towerData[selectedTowerType].slowEffect || 0,
                slowDuration: towerData[selectedTowerType].slowDuration || 0
            };
            
            towers.push(tower);
            money -= cost;
            gameStats.towersBuilt++;
            gameStats.totalMoneyEarned += cost;
            
            if (selectedTowerType === 'sunflower') {
                gameStats.sunflowersBuilt++;
            }
            
            updateGameInfo();
            checkAchievements();
            
            // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºé˜²å¾¡å¡”
            const towerElement = document.createElement('div');
            towerElement.className = `tower ${selectedTowerType}`;
            towerElement.style.left = `${x-25}px`;
            towerElement.style.top = `${y-25}px`;
            towerElement.textContent = towerData[selectedTowerType].emoji;
            
            // æ·»åŠ ç­‰çº§æ ‡ç­¾
            const levelElement = document.createElement('div');
            levelElement.className = 'tower-level';
            levelElement.textContent = tower.level;
            towerElement.appendChild(levelElement);
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç”¨äºå‡çº§
            towerElement.addEventListener('click', function(e) {
                e.stopPropagation();
                if (gameRunning || gamePaused) return;
                openUpgradeMenu(tower, towerElement);
            });
            
            document.getElementById('game-board').appendChild(towerElement);
            tower.element = towerElement;
            tower.levelElement = levelElement;
            towerElements.push(towerElement);
            
            // å¦‚æœæ˜¯åœ°é›·ï¼Œæ˜¾ç¤ºä¸åŒçš„çŠ¶æ€
            if (tower.isMine) {
                towerElement.textContent = 'â³';
                tower.mineTimer = setTimeout(() => {
                    tower.mineActive = true;
                    towerElement.textContent = 'ğŸ’£';
                }, 3000);
            }
            
            // å¦‚æœæ˜¯å‘æ—¥è‘µï¼Œå¼€å§‹äº§ç”Ÿæ”¶å…¥
            if (tower.type === 'sunflower' && !sunflowerInterval) {
                sunflowerInterval = setInterval(produceIncome, 1000);
            }
            
            showMessage(`${getTowerName(selectedTowerType)} å·²æ”¾ç½®!`);
            playSound('placeTower');
        });
        
        // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è·¯å¾„ä¸Š
        function isOnPath(x, y) {
            // æ£€æŸ¥æ‰€æœ‰è·¯å¾„æ®µ
            const paths = [
                { x1: 50, y1: 100, x2: 150, y2: 130 },   // ç¬¬ä¸€æ®µæ°´å¹³è·¯å¾„
                { x1: 150, y1: 100, x2: 180, y2: 150 },   // ç¬¬ä¸€æ®µå‚ç›´è·¯å¾„
                { x1: 150, y1: 150, x2: 250, y2: 180 },   // ç¬¬äºŒæ®µæ°´å¹³è·¯å¾„
                { x1: 250, y1: 150, x2: 280, y2: 200 },   // ç¬¬äºŒæ®µå‚ç›´è·¯å¾„
                { x1: 250, y1: 200, x2: 350, y2: 230 },   // ç¬¬ä¸‰æ®µæ°´å¹³è·¯å¾„
                { x1: 350, y1: 200, x2: 380, y2: 250 },   // ç¬¬ä¸‰æ®µå‚ç›´è·¯å¾„
                { x1: 350, y1: 250, x2: 450, y2: 280 },   // ç¬¬å››æ®µæ°´å¹³è·¯å¾„
                { x1: 450, y1: 250, x2: 480, y2: 300 },   // ç¬¬å››æ®µå‚ç›´è·¯å¾„
                { x1: 450, y1: 300, x2: 550, y2: 330 }    // ç¬¬äº”æ®µæ°´å¹³è·¯å¾„
            ];
            
            for (const path of paths) {
                if (x >= path.x1 && x <= path.x2 && y >= path.y1 && y <= path.y2) {
                    return true;
                }
            }
            return false;
        }
        
        // æ‰“å¼€å‡çº§èœå•
        function openUpgradeMenu(tower, element) {
            closeUpgradeMenu(); // å…³é—­ä»»ä½•å·²æ‰“å¼€çš„å‡çº§èœå•
            
            selectedTowerForUpgrade = tower;
            
            const menu = document.getElementById('upgrade-menu');
            const options = document.getElementById('upgrade-options');
            options.innerHTML = '';
            
            // è®¾ç½®å‡ºå”®ä»·å€¼ï¼ˆåŸä»·çš„75%ï¼‰
            const sellValue = Math.round(getTowerCost(tower.type) * 0.75 * tower.level);
            document.getElementById('sell-value').textContent = sellValue;
            
            // æ·»åŠ å‡çº§é€‰é¡¹
            if (!tower.isMine) {
                const upgradeCost = getUpgradeCost(tower.type, tower.level);
                const upgradeOption = document.createElement('div');
                upgradeOption.className = 'upgrade-option';
                upgradeOption.innerHTML = `å‡çº§åˆ°ç­‰çº§ ${tower.level + 1} <span class="upgrade-cost">${upgradeCost}é‡‘å¸</span>`;
                upgradeOption.onclick = function() {
                    if (money >= upgradeCost) {
                        upgradeTower(tower, upgradeCost);
                    } else {
                        showMessage("é‡‘å¸ä¸è¶³!");
                    }
                };
                options.appendChild(upgradeOption);
            }
            
            // å®šä½èœå•
            menu.style.display = 'block';
            const boardRect = document.getElementById('game-board').getBoundingClientRect();
            const x = tower.x + boardRect.left;
            const y = tower.y + boardRect.top;
            
            // ç¡®ä¿èœå•ä¸ä¼šè¶…å‡ºæ¸¸æˆåŒºåŸŸ
            let left = x + 30;
            let top = y - 20;
            
            if (left + 200 > window.innerWidth) {
                left = window.innerWidth - 220;
            }
            
            if (top + 100 > window.innerHeight) {
                top = window.innerHeight - 120;
            }
            
            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            setTimeout(() => {
                document.addEventListener('click', closeUpgradeMenu);
            }, 10);
        }
        
        // å…³é—­å‡çº§èœå•
        function closeUpgradeMenu() {
            document.getElementById('upgrade-menu').style.display = 'none';
            document.removeEventListener('click', closeUpgradeMenu);
            selectedTowerForUpgrade = null;
        }
        
        // å‡çº§é˜²å¾¡å¡”
        function upgradeTower(tower, cost) {
            money -= cost;
            gameStats.totalMoneyEarned += cost;
            tower.level++;
            gameStats.towersUpgraded++;
            
            // æ›´æ–°å±æ€§
            tower.damage = towerData[tower.type].damage + (towerData[tower.type].damagePerLevel * (tower.level - 1));
            if (towerData[tower.type].rangePerLevel) {
                tower.range = towerData[tower.type].range + (towerData[tower.type].rangePerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].incomePerLevel) {
                tower.income = towerData[tower.type].income + (towerData[tower.type].incomePerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].stunPerLevel) {
                tower.stunDuration = towerData[tower.type].stunDuration + (towerData[tower.type].stunPerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].critPerLevel) {
                tower.critChance = towerData[tower.type].critChance + (towerData[tower.type].critPerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].splashPerLevel) {
                tower.splashRadius = towerData[tower.type].splashRadius + (towerData[tower.type].splashPerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].poisonPerLevel) {
                tower.poisonChance = towerData[tower.type].poisonChance + (towerData[tower.type].poisonPerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].piercePerLevel) {
                tower.pierceChance = towerData[tower.type].pierceChance + (towerData[tower.type].piercePerLevel * (tower.level - 1));
            }
            if (towerData[tower.type].slowPerLevel) {
                tower.slowEffect = towerData[tower.type].slowEffect + (towerData[tower.type].slowPerLevel * (tower.level - 1));
            }
            
            // æ›´æ–°ç­‰çº§æ˜¾ç¤º
            tower.levelElement.textContent = tower.level;
            
            updateGameInfo();
            closeUpgradeMenu();
            showMessage(`${getTowerName(tower.type)} å·²å‡çº§åˆ°ç­‰çº§ ${tower.level}!`);
            playSound('upgrade');
            checkAchievements();
        }
        
        // å‡ºå”®é˜²å¾¡å¡”
        function sellTower() {
            if (!selectedTowerForUpgrade) return;
            
            const tower = selectedTowerForUpgrade;
            const sellValue = Math.round(getTowerCost(tower.type) * 0.75 * tower.level);
            
            // ç§»é™¤å¡”
            const index = towers.indexOf(tower);
            if (index !== -1) {
                towers.splice(index, 1);
            }
            
            // ç§»é™¤å…ƒç´ 
            if (tower.element.parentNode) {
                tower.element.parentNode.removeChild(tower.element);
            }
            
            // å¦‚æœæ˜¯åœ°é›·ä¸”è®¡æ—¶å™¨å­˜åœ¨ï¼Œæ¸…é™¤è®¡æ—¶å™¨
            if (tower.isMine && tower.mineTimer) {
                clearTimeout(tower.mineTimer);
            }
            
            money += sellValue;
            gameStats.totalMoneyEarned += sellValue;
            updateGameInfo();
            closeUpgradeMenu();
            showMessage(`å·²å‡ºå”® ${getTowerName(tower.type)} è·å¾— ${sellValue}é‡‘å¸!`);
            playSound('sell');
            
            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å‘æ—¥è‘µ
            const hasSunflowers = towers.some(t => t.type === 'sunflower');
            if (!hasSunflowers && sunflowerInterval) {
                clearInterval(sunflowerInterval);
                sunflowerInterval = null;
            }
        }
        
        // å‘æ—¥è‘µäº§ç”Ÿæ”¶å…¥
        function produceIncome() {
            const now = Date.now();
            let incomeGenerated = false;
            
            towers.forEach(tower => {
                if (tower.type === 'sunflower' && now - tower.lastIncomeTime >= tower.incomeInterval) {
                    money += tower.income;
                    gameStats.totalMoneyEarned += tower.income;
                    tower.lastIncomeTime = now;
                    incomeGenerated = true;
                    
                    // æ˜¾ç¤ºæ”¶å…¥åŠ¨ç”»
                    const incomeText = document.createElement('div');
                    incomeText.textContent = `+${tower.income}`;
                    incomeText.style.position = 'absolute';
                    incomeText.style.left = `${tower.x-10}px`;
                    incomeText.style.top = `${tower.y-30}px`;
                    incomeText.style.color = 'gold';
                    incomeText.style.fontWeight = 'bold';
                    incomeText.style.fontSize = '20px';
                    incomeText.style.zIndex = '10';
                    document.getElementById('game-board').appendChild(incomeText);
                    
                    setTimeout(() => {
                        incomeText.style.top = `${tower.y-50}px`;
                        incomeText.style.opacity = '0';
                        setTimeout(() => {
                            incomeText.remove();
                        }, 500);
                    }, 100);
                }
            });
            
            if (incomeGenerated) {
                updateGameInfo();
                checkAchievements();
            }
        }
        
        // å¼€å§‹æ³¢æ¬¡
        function startWave() {
            if (gameRunning || gamePaused) return;
            
            wave++;
            if (wave > maxWave) {
                maxWave = wave;
            }
            
            updateGameInfo();
            gameRunning = true;
            document.getElementById('start-button').disabled = true;
            showMessage(`ç¬¬ ${wave} æ³¢å¼€å§‹!`);
            playSound('waveStart');
            
            // ç‰¹æ®Šæ³¢æ¬¡æç¤º
            if (wave % 5 === 0) {
                const specialWave = document.createElement('div');
                specialWave.className = 'special-wave';
                specialWave.textContent = `ç‰¹æ®Šæ³¢æ¬¡ ${wave}!`;
                document.getElementById('game-board').appendChild(specialWave);
                
                setTimeout(() => {
                    specialWave.remove();
                }, 2000);
            }
            
            // ç”Ÿæˆæ•Œäºº
            let enemyCount = 5 + Math.floor(wave * 1.5);
            
            // ç‰¹æ®Šæ³¢æ¬¡æœ‰æ›´å¤šæ•Œäºº
            if (wave % 5 === 0) {
                enemyCount = Math.floor(enemyCount * 1.5);
            }
            
            // å›°éš¾æ¨¡å¼20æ³¢åå‡ºç°èƒ¡èåœå·¨äºº
            if (difficulty === 'hard' && wave >= 20 && Math.random() < 0.3) {
                setTimeout(() => {
                    if (lives <= 0 || gamePaused) return;
                    createEnemy('ğŸ¥•'); // èƒ¡èåœå·¨äºº
                }, 2000);
                enemyCount = Math.floor(enemyCount * 0.7); // å‡å°‘æ™®é€šæ•Œäººæ•°é‡
            }
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    if (lives <= 0 || gamePaused) return;
                    createEnemy();
                }, i * 1000);
            }
            
            // æ£€æŸ¥æ³¢æ¬¡æ˜¯å¦ç»“æŸ
            setTimeout(() => {
                gameRunning = false;
                document.getElementById('start-button').disabled = false;
                
                if (lives > 0) {
                    const waveBonus = Math.round((20 + wave * 5) * difficultySettings[difficulty].rewardMultiplier);
                    showMessage(`ç¬¬ ${wave} æ³¢ç»“æŸ! è·å¾— ${waveBonus}é‡‘å¸å¥–åŠ±`);
                    money += waveBonus;
                    gameStats.totalMoneyEarned += waveBonus;
                    
                    // æ£€æŸ¥æ˜¯å¦å®Œç¾æ³¢æ¬¡ï¼ˆæ— ç”Ÿå‘½æŸå¤±ï¼‰
                    if (lives === difficultySettings[difficulty].startingLives) {
                        gameStats.perfectWaves++;
                        checkAchievements();
                    }
                    
                    updateGameInfo();
                    checkAchievements();
                }
            }, enemyCount * 1000 + 2000);
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            if (!window.gameLoop) {
                window.gameLoop = setInterval(updateGame, 16);
            }
        }
        
        // æš‚åœ/ç»§ç»­æ¸¸æˆ
        function togglePause() {
            gamePaused = !gamePaused;
            
            if (gamePaused) {
                document.getElementById('pause-button').textContent = 'ç»§ç»­';
                showMessage("æ¸¸æˆå·²æš‚åœ");
            } else {
                document.getElementById('pause-button').textContent = 'æš‚åœ';
                showMessage("æ¸¸æˆå·²ç»§ç»­");
            }
            
            playSound('click');
        }
        
        // åˆ‡æ¢éŸ³æ•ˆ
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-control').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            document.getElementById('volume-control').style.display = soundEnabled ? 'block' : 'none';
            playSound('click');
        }
        
        // è°ƒæ•´éŸ³é‡
        document.getElementById('volume-slider').addEventListener('input', function() {
            const volume = parseFloat(this.value);
            Object.values(sounds).forEach(sound => {
                sound.volume = volume;
            });
        });
        
        // åˆ›å»ºæ•Œäºº
        function createEnemy(specificType) {
            const enemyTypes = ['ğŸ›', 'ğŸ›', 'ğŸ›', 'ğŸ‡', 'ğŸ‡', 'ğŸ€', 'ğŸ¦', 'ğŸŒ', 'ğŸ¦—', 'ğŸ¦', 'ğŸ', 'ğŸœ', 'ğŸ¦‚'];
            let enemyType = specificType || enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            // éšç€æ³¢æ•°å¢åŠ ï¼Œå‡ºç°æ›´å¼ºæ•Œäººçš„æ¦‚ç‡å¢åŠ 
            if (!specificType && Math.random() < wave * 0.05) {
                enemyType = ['ğŸ€', 'ğŸ¦', 'ğŸŒ', 'ğŸ¦', 'ğŸ¦‚'][Math.floor(Math.random() * 5)];
            }
            
            // åæœŸå‡ºç°æ–°æ•Œäºº
            if (!specificType && wave >= 8 && Math.random() < 0.1) {
                enemyType = 'ğŸ§ª'; // æ¯’æ¶²èœ—ç‰›
            }
            if (!specificType && wave >= 10 && Math.random() < 0.1) {
                enemyType = 'ğŸ›¡ï¸'; // è£…ç”²è™«
            }
            if (!specificType && wave >= 12 && Math.random() < 0.1) {
                enemyType = 'ğŸ§™'; // é­”æ³•å…”
            }
            if (!specificType && wave >= 15 && Math.random() < 0.1) {
                enemyType = 'ğŸ²'; // å·¨é¾™
            }
            
            // ç‰¹æ®Šæ³¢æ¬¡å¯èƒ½å‡ºç°ç‰¹æ®Šæ•Œäºº
            if (!specificType && wave % 5 === 0) {
                if (Math.random() < 0.3) {
                    enemyType = Math.random() < 0.5 ? 'ğŸº' : 'ğŸ¦…';
                }
            }
            
            // èš‚èšæˆç¾¤å‡ºç°
            if (!specificType && enemyType === 'ğŸœ') {
                const antCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < antCount; i++) {
                    setTimeout(() => createSingleEnemy('ğŸœ'), i * 300);
                }
                return;
            }
            
            createSingleEnemy(enemyType);
        }
        
        // åˆ›å»ºå•ä¸ªæ•Œäºº
        function createSingleEnemy(enemyType) {
            let health, speed, reward, bossDamageMultiplier = 1;
            const settings = difficultySettings[difficulty];
            
            switch(enemyType) {
                case 'ğŸ›':
                    health = Math.round((30 + wave * 5) * settings.enemyHealthMultiplier);
                    speed = 1 * settings.enemySpeedMultiplier;
                    reward = 5;
                    break;
                case 'ğŸ‡':
                    health = Math.round((50 + wave * 8) * settings.enemyHealthMultiplier);
                    speed = 2 * settings.enemySpeedMultiplier;
                    reward = 10;
                    break;
                case 'ğŸ€':
                    health = Math.round((80 + wave * 12) * settings.enemyHealthMultiplier);
                    speed = 0.8 * settings.enemySpeedMultiplier;
                    reward = 15;
                    break;
                case 'ğŸ¦':
                    health = Math.round((60 + wave * 10) * settings.enemyHealthMultiplier);
                    speed = 1.5 * settings.enemySpeedMultiplier;
                    reward = 12;
                    break;
                case 'ğŸŒ':
                    health = Math.round((120 + wave * 15) * settings.enemyHealthMultiplier);
                    speed = 0.5 * settings.enemySpeedMultiplier;
                    reward = 20;
                    break;
                case 'ğŸ¦—':
                    health = Math.round((40 + wave * 6) * settings.enemyHealthMultiplier);
                    speed = 2.5 * settings.enemySpeedMultiplier;
                    reward = 8;
                    break;
                case 'ğŸ¦':
                    health = Math.round((70 + wave * 10) * settings.enemyHealthMultiplier);
                    speed = 1.2 * settings.enemySpeedMultiplier;
                    reward = 14;
                    break;
                case 'ğŸ':
                    health = Math.round((45 + wave * 7) * settings.enemyHealthMultiplier);
                    speed = 1.8 * settings.enemySpeedMultiplier;
                    reward = 10;
                    break;
                case 'ğŸœ':
                    health = Math.round((25 + wave * 4) * settings.enemyHealthMultiplier);
                    speed = 1.3 * settings.enemySpeedMultiplier;
                    reward = 5;
                    break;
                case 'ğŸ¦‚':
                    health = Math.round((90 + wave * 13) * settings.enemyHealthMultiplier);
                    speed = 0.7 * settings.enemySpeedMultiplier;
                    reward = 18;
                    break;
                case 'ğŸº': // ç‰¹æ®Šæ•Œäºº - ç‹¼
                    health = Math.round((150 + wave * 20) * settings.enemyHealthMultiplier);
                    speed = 1.5 * settings.enemySpeedMultiplier;
                    reward = 25;
                    bossDamageMultiplier = 2.5; // BOSSå¯¹èƒ¡èåœé€ æˆ2.5å€ä¼¤å®³
                    break;
                case 'ğŸ¦…': // ç‰¹æ®Šæ•Œäºº - è€é¹°
                    health = Math.round((100 + wave * 15) * settings.enemyHealthMultiplier);
                    speed = 2 * settings.enemySpeedMultiplier;
                    reward = 30;
                    bossDamageMultiplier = 2.5; // BOSSå¯¹èƒ¡èåœé€ æˆ2.5å€ä¼¤å®³
                    break;
                // æ–°æ•Œäºº
                case 'ğŸ²': // å·¨é¾™
                    health = Math.round((200 + wave * 25) * settings.enemyHealthMultiplier);
                    speed = 1.2 * settings.enemySpeedMultiplier;
                    reward = 50;
                    break;
                case 'ğŸ§™': // é­”æ³•å…”
                    health = Math.round((100 + wave * 15) * settings.enemyHealthMultiplier);
                    speed = 0.8 * settings.enemySpeedMultiplier;
                    reward = 25;
                    break;
                case 'ğŸ›¡ï¸': // è£…ç”²è™«
                    health = Math.round((150 + wave * 20) * settings.enemyHealthMultiplier);
                    speed = 0.6 * settings.enemySpeedMultiplier;
                    reward = 30;
                    break;
                case 'ğŸ§ª': // æ¯’æ¶²èœ—ç‰›
                    health = Math.round((90 + wave * 12) * settings.enemyHealthMultiplier);
                    speed = 0.4 * settings.enemySpeedMultiplier;
                    reward = 20;
                    break;
                case 'ğŸ¥•': // èƒ¡èåœå·¨äºº (å›°éš¾æ¨¡å¼ä¸“å±BOSS)
                    health = Math.round((500 + wave * 30) * settings.enemyHealthMultiplier);
                    speed = 0.3 * settings.enemySpeedMultiplier;
                    reward = 100;
                    bossDamageMultiplier = 3; // å¯¹èƒ¡èåœé€ æˆ3å€ä¼¤å®³
                    break;
            }
            
            const enemy = {
                type: enemyType,
                x: path[0].x,
                y: path[0].y,
                health: health,
                maxHealth: health,
                speed: speed,
                reward: reward,
                pathIndex: 0,
                element: null,
                isFlying: enemyType === 'ğŸ¦' || enemyType === 'ğŸ' || enemyType === 'ğŸ¦…' || enemyType === 'ğŸ²',
                stunTimer: 0,
                dodgeChance: enemyType === 'ğŸ¦' ? 0.2 : 0,
                canDisableTowers: enemyType === 'ğŸ¦‚' || enemyType === 'ğŸ²',
                disableTimer: 0,
                isBoss: enemyType === 'ğŸº' || enemyType === 'ğŸ¦…' || enemyType === 'ğŸ¥•',
                bossDamageMultiplier: bossDamageMultiplier, // BOSSä¼¤å®³å€æ•°
                originalSpeed: speed,
                // æ–°æ•Œäººç‰¹æœ‰å±æ€§
                isArmored: enemyType === 'ğŸ›¡ï¸',
                armor: enemyType === 'ğŸ›¡ï¸' ? 0.3 : 0, // å‡å°‘30%ä¼¤å®³
                isToxic: enemyType === 'ğŸ§ª',
                summonMinions: enemyType === 'ğŸ§™',
                minionCooldown: 0,
                // èƒ¡èåœå·¨äººç‰¹æœ‰å±æ€§
                isGolem: enemyType === 'ğŸ¥•',
                immuneToSlow: enemyType === 'ğŸ¥•',
                immuneToStun: enemyType === 'ğŸ¥•'
            };
            
            enemies.push(enemy);
            
            // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæ•Œäºº
            const enemyElement = document.createElement('div');
            enemyElement.className = `enemy ${enemyType}`;
            enemyElement.textContent = enemyType;
            
            // å¦‚æœæ˜¯BOSSæ•Œäººï¼Œæ”¾å¤§æ˜¾ç¤º
            if (enemy.isBoss) {
                enemyElement.style.fontSize = '40px';
                enemyElement.style.zIndex = '4';
                
                // èƒ¡èåœå·¨äººæ›´å¤§
                if (enemyType === 'ğŸ¥•') {
                    enemyElement.style.fontSize = '50px';
                    enemyElement.style.zIndex = '5';
                    enemyElement.classList.add('carrot-golem');
                    
                    // æ˜¾ç¤ºBOSSè­¦å‘Š
                    const bossWarning = document.createElement('div');
                    bossWarning.className = 'special-wave';
                    bossWarning.textContent = 'èƒ¡èåœå·¨äººå‡ºç°!';
                    bossWarning.style.backgroundColor = 'rgba(255, 87, 34, 0.8)';
                    document.getElementById('game-board').appendChild(bossWarning);
                    
                    setTimeout(() => {
                        bossWarning.remove();
                    }, 3000);
                }
            }
            
            enemyElement.style.left = `${enemy.x-15}px`;
            enemyElement.style.top = `${enemy.y-15}px`;
            
            // æ·»åŠ è¡€æ¡
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'health-fill';
            healthBar.appendChild(healthFill);
            enemyElement.appendChild(healthBar);
            
            document.getElementById('game-board').appendChild(enemyElement);
            enemy.element = enemyElement;
            enemy.healthFill = healthFill;
            enemyElements.push(enemyElement);
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function updateGame() {
            if (gamePaused) return;
            
            gameStats.gameTime += 16;
            
            // æ›´æ–°æ•Œäººä½ç½®
            enemies.forEach(enemy => {
                // å¦‚æœæ•Œäººè¢«çœ©æ™•ï¼Œè·³è¿‡ç§»åŠ¨
                if (enemy.stunTimer > 0 && !enemy.immuneToStun) {
                    enemy.stunTimer -= 16;
                    return;
                }
                
                const target = path[enemy.pathIndex];
                const dx = target.x - enemy.x;
                const dy = target.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < enemy.speed) {
                    enemy.x = target.x;
                    enemy.y = target.y;
                    enemy.pathIndex++;
                    
                    if (enemy.pathIndex >= path.length) {
                        // æ•Œäººåˆ°è¾¾ç»ˆç‚¹ï¼Œæ ¹æ®æ•Œäººç±»å‹è®¡ç®—ä¼¤å®³
                        const damage = enemy.isBoss ? 2 * enemy.bossDamageMultiplier : 1;
                        lives -= damage;
                        updateGameInfo();
                        removeEnemy(enemy);
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                        return;
                    }
                } else {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                enemy.element.style.left = `${enemy.x-15}px`;
                enemy.element.style.top = `${enemy.y-15}px`;
                
                // é­”æ³•å…”å¬å”¤å°å…”
                if (enemy.summonMinions && enemy.minionCooldown <= 0) {
                    if (Math.random() < 0.01) {
                        createSingleEnemy('ğŸ‡');
                        enemy.minionCooldown = 5000;
                        
                        // æ˜¾ç¤ºå¬å”¤æ•ˆæœ
                        const summonEffect = document.createElement('div');
                        summonEffect.textContent = 'âœ¨';
                        summonEffect.style.position = 'absolute';
                        summonEffect.style.left = `${enemy.x-15}px`;
                        summonEffect.style.top = `${enemy.y-30}px`;
                        document.getElementById('game-board').appendChild(summonEffect);
                        
                        setTimeout(() => {
                            summonEffect.remove();
                        }, 1000);
                    }
                } else {
                    enemy.minionCooldown -= 16;
                }
                
                // æ¯’æ¶²èœ—ç‰›ç•™ä¸‹æ¯’æ¶²
                if (enemy.isToxic && Math.random() < 0.02) {
                    // åˆ›å»ºæ¯’æ¶²æ•ˆæœ
                    const toxicEffect = document.createElement('div');
                    toxicEffect.textContent = 'ğŸ’§';
                    toxicEffect.style.position = 'absolute';
                    toxicEffect.style.left = `${enemy.x-10}px`;
                    toxicEffect.style.top = `${enemy.y-10}px`;
                    toxicEffect.style.fontSize = '20px';
                    toxicEffect.style.color = '#7cb342';
                    toxicEffect.style.zIndex = '2';
                    toxicEffect.style.opacity = '0.7';
                    document.getElementById('game-board').appendChild(toxicEffect);
                    
                    setTimeout(() => {
                        toxicEffect.remove();
                    }, 5000);
                }
            });
            
            // æ›´æ–°é˜²å¾¡å¡”æ”»å‡»
            towers.forEach(tower => {
                // å¦‚æœå¡”è¢«ç¦ç”¨ï¼Œè·³è¿‡æ”»å‡»
                if (tower.disableTimer > 0) {
                    tower.disableTimer -= 16;
                    return;
                }
                
                if (tower.isMine) {
                    // å¤„ç†åœ°é›·
                    if (tower.mineActive) {
                        enemies.forEach(enemy => {
                            const dx = enemy.x - tower.x;
                            const dy = enemy.y - tower.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 60) {
                                // åœ°é›·çˆ†ç‚¸
                                enemy.health -= tower.damage;
                                enemy.healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                                if (enemy.health <= 0) {
                                    money += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                    gameStats.enemiesDefeated++;
                                    gameStats.totalMoneyEarned += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                    if (enemy.isGolem) {
                                        gameStats.bossesDefeated++;
                                    }
                                    updateGameInfo();
                                    removeEnemy(enemy);
                                    checkAchievements();
                                }
                                
                                // ç§»é™¤åœ°é›·
                                tower.element.remove();
                                const index = towers.indexOf(tower);
                                if (index !== -1) {
                                    towers.splice(index, 1);
                                }
                                
                                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                                const explosion = document.createElement('div');
                                explosion.className = 'projectile';
                                explosion.textContent = 'ğŸ’¥';
                                explosion.style.left = `${tower.x-20}px`;
                                explosion.style.top = `${tower.y-20}px`;
                                explosion.style.fontSize = '40px';
                                document.getElementById('game-board').appendChild(explosion);
                                projectileElements.push(explosion);
                                
                                setTimeout(() => {
                                    explosion.remove();
                                    const index = projectileElements.indexOf(explosion);
                                    if (index !== -1) {
                                        projectileElements.splice(index, 1);
                                    }
                                }, 500);
                                
                                playSound('enemyDefeated');
                            }
                        });
                    }
                    return;
                }
                
                if (tower.cooldown > 0) {
                    tower.cooldown -= 16;
                    return;
                }
                
                // å¯»æ‰¾æœ€è¿‘çš„æ•Œäºº
                let closestEnemy = null;
                let minDistance = Infinity;
                
                enemies.forEach(enemy => {
                    // é£è¡Œæ•Œäººåªèƒ½è¢«ç‰¹å®šå¡”æ”»å‡»
                    if (enemy.isFlying && tower.type !== 'corn-cannon' && tower.type !== 'melon-pult' && 
                        tower.type !== 'cactus' && tower.type !== 'mushroom') return;
                    
                    const dx = enemy.x - tower.x;
                    const dy = enemy.y - tower.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < tower.range && distance < minDistance) {
                        closestEnemy = enemy;
                        minDistance = distance;
                    }
                });
                
                if (closestEnemy) {
                    // æ”»å‡»æ•Œäºº
                    tower.cooldown = towerData[tower.type].cooldown;
                    createProjectile(tower, closestEnemy);
                    playSound('towerAttack');
                }
            });
            
            // æ›´æ–°æŠ•å°„ç‰©
            projectiles.forEach((proj, index) => {
                const dx = proj.target.x - proj.x;
                const dy = proj.target.y - proj.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    // æ£€æŸ¥æ•Œäººæ˜¯å¦é—ªé¿
                    if (proj.target.dodgeChance > 0 && Math.random() < proj.target.dodgeChance) {
                        // æ˜¾ç¤ºé—ªé¿æ•ˆæœ
                        const dodgeText = document.createElement('div');
                        dodgeText.textContent = 'é—ªé¿!';
                        dodgeText.style.position = 'absolute';
                        dodgeText.style.left = `${proj.target.x-15}px`;
                        dodgeText.style.top = `${proj.target.y-30}px`;
                        dodgeText.style.color = '#2196F3';
                        dodgeText.style.fontWeight = 'bold';
                        document.getElementById('game-board').appendChild(dodgeText);
                        
                        setTimeout(() => {
                            dodgeText.remove();
                        }, 500);
                    } else {
                        // è®¡ç®—ä¼¤å®³
                        let damage = proj.damage;
                        
                        // è£…ç”²æ•Œäººå‡å°‘ä¼¤å®³
                        if (proj.target.isArmored) {
                            damage = Math.round(damage * (1 - proj.target.armor));
                        }
                        
                        // æ£€æŸ¥æš´å‡»
                        if (proj.critChance && Math.random() < proj.critChance) {
                            damage *= 2;
                            
                            // æ˜¾ç¤ºæš´å‡»æ•ˆæœ
                            const critText = document.createElement('div');
                            critText.textContent = 'æš´å‡»!';
                            critText.style.position = 'absolute';
                            critText.style.left = `${proj.target.x-15}px`;
                            critText.style.top = `${proj.target.y-30}px`;
                            critText.style.color = '#FF5722';
                            critText.style.fontWeight = 'bold';
                            document.getElementById('game-board').appendChild(critText);
                            
                            setTimeout(() => {
                                critText.remove();
                            }, 500);
                        }
                        
                        // é€ æˆä¼¤å®³
                        proj.target.health -= damage;
                        proj.target.healthFill.style.width = `${(proj.target.health / proj.target.maxHealth) * 100}%`;
                        
                        // å¦‚æœæ˜¯å¤§è’œå¡”ï¼Œçœ©æ™•æ•Œäºº
                        if (proj.stunDuration > 0 && !proj.target.immuneToStun) {
                            proj.target.stunTimer = proj.stunDuration;
                            
                            // æ˜¾ç¤ºçœ©æ™•æ•ˆæœ
                            const stunEffect = document.createElement('div');
                            stunEffect.textContent = 'ğŸ’«';
                            stunEffect.style.position = 'absolute';
                            stunEffect.style.left = `${proj.target.x-15}px`;
                            stunEffect.style.top = `${proj.target.y-30}px`;
                            document.getElementById('game-board').appendChild(stunEffect);
                            
                            setTimeout(() => {
                                stunEffect.remove();
                            }, proj.stunDuration);
                        }
                        
                        // å¦‚æœæ˜¯è‰è“å°„æ‰‹ï¼Œä½¿æ•Œäººä¸­æ¯’
                        if (proj.poisonChance && Math.random() < proj.poisonChance) {
                            proj.target.poisoned = {
                                damage: proj.poisonDamage,
                                duration: proj.poisonDuration,
                                timer: proj.poisonDuration
                            };
                            
                            // æ˜¾ç¤ºä¸­æ¯’æ•ˆæœ
                            const poisonEffect = document.createElement('div');
                            poisonEffect.textContent = 'â˜ ï¸';
                            poisonEffect.style.position = 'absolute';
                            poisonEffect.style.left = `${proj.target.x-15}px`;
                            poisonEffect.style.top = `${proj.target.y-30}px`;
                            document.getElementById('game-board').appendChild(poisonEffect);
                            
                            setTimeout(() => {
                                poisonEffect.remove();
                            }, proj.poisonDuration);
                        }
                        
                        // å¦‚æœæ˜¯èå­æˆ–å·¨é¾™ï¼Œç¦ç”¨é˜²å¾¡å¡”
                        if (proj.target.canDisableTowers) {
                            // æ‰¾åˆ°æœ€è¿‘çš„é˜²å¾¡å¡”
                            let closestTower = null;
                            let minDistance = Infinity;
                            
                            towers.forEach(tower => {
                                if (!tower.isMine) {
                                    const dx = tower.x - proj.target.x;
                                    const dy = tower.y - proj.target.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < 100 && distance < minDistance) {
                                        closestTower = tower;
                                        minDistance = distance;
                                    }
                                }
                            });
                            
                            if (closestTower) {
                                closestTower.disableTimer = 3000; // ç¦ç”¨3ç§’
                                
                                // æ˜¾ç¤ºç¦ç”¨æ•ˆæœ
                                const disableEffect = document.createElement('div');
                                disableEffect.textContent = 'âŒ';
                                disableEffect.style.position = 'absolute';
                                disableEffect.style.left = `${closestTower.x-15}px`;
                                disableEffect.style.top = `${closestTower.y-30}px`;
                                disableEffect.style.fontSize = '20px';
                                document.getElementById('game-board').appendChild(disableEffect);
                                
                                setTimeout(() => {
                                    disableEffect.remove();
                                }, 3000);
                            }
                        }
                        
                        // å¦‚æœæ˜¯è¥¿ç“œæŠ•æ‰‹æˆ–è èç‚¸å¼¹ï¼Œé€ æˆæº…å°„ä¼¤å®³
                        if (proj.splashRadius > 0) {
                            enemies.forEach(enemy => {
                                if (enemy !== proj.target) {
                                    const dx = enemy.x - proj.target.x;
                                    const dy = enemy.y - proj.target.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < proj.splashRadius) {
                                        let splashDamage = damage * 0.5; // æº…å°„ä¼¤å®³ä¸º50%
                                        
                                        // è£…ç”²æ•Œäººå‡å°‘ä¼¤å®³
                                        if (enemy.isArmored) {
                                            splashDamage = Math.round(splashDamage * (1 - enemy.armor));
                                        }
                                        
                                        enemy.health -= splashDamage;
                                        enemy.healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                                        
                                        if (enemy.health <= 0) {
                                            money += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                            gameStats.enemiesDefeated++;
                                            gameStats.totalMoneyEarned += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                            if (enemy.isGolem) {
                                                gameStats.bossesDefeated++;
                                            }
                                            updateGameInfo();
                                            removeEnemy(enemy);
                                            checkAchievements();
                                        }
                                    }
                                }
                            });
                        }
                        
                        // å¦‚æœæ˜¯ä»™äººæŒå°„æ‰‹ï¼Œæœ‰å‡ ç‡ç©¿é€æ•Œäºº
                        if (proj.pierceChance && Math.random() < proj.pierceChance) {
                            // å¯»æ‰¾ç©¿é€è·¯å¾„ä¸Šçš„å…¶ä»–æ•Œäºº
                            enemies.forEach(enemy => {
                                if (enemy !== proj.target) {
                                    const dx = enemy.x - proj.target.x;
                                    const dy = enemy.y - proj.target.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    // æ£€æŸ¥æ˜¯å¦åœ¨ç©¿é€è·¯å¾„ä¸Š
                                    if (distance < 100 && Math.abs(Math.atan2(dy, dx) - Math.atan2(proj.dy, proj.dx)) < 0.2) {
                                        let pierceDamage = damage * 0.7; // ç©¿é€ä¼¤å®³ä¸º70%
                                        
                                        // è£…ç”²æ•Œäººå‡å°‘ä¼¤å®³
                                        if (enemy.isArmored) {
                                            pierceDamage = Math.round(pierceDamage * (1 - enemy.armor));
                                        }
                                        
                                        enemy.health -= pierceDamage;
                                        enemy.healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                                        
                                        if (enemy.health <= 0) {
                                            money += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                            gameStats.enemiesDefeated++;
                                            gameStats.totalMoneyEarned += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                                            if (enemy.isGolem) {
                                                gameStats.bossesDefeated++;
                                            }
                                            updateGameInfo();
                                            removeEnemy(enemy);
                                            checkAchievements();
                                        }
                                    }
                                }
                            });
                        }
                        
                        // å¦‚æœæ˜¯è˜‘è‡äº‘ï¼Œå‡é€Ÿæ•Œäºº
                        if (proj.slowEffect > 0 && !proj.target.immuneToSlow) {
                            proj.target.slowed = {
                                effect: proj.slowEffect,
                                duration: proj.slowDuration,
                                timer: proj.slowDuration
                            };
                            
                            // æ˜¾ç¤ºå‡é€Ÿæ•ˆæœ
                            const slowEffect = document.createElement('div');
                            slowEffect.textContent = 'ğŸŒ';
                            slowEffect.style.position = 'absolute';
                            slowEffect.style.left = `${proj.target.x-15}px`;
                            slowEffect.style.top = `${proj.target.y-30}px`;
                            document.getElementById('game-board').appendChild(slowEffect);
                            
                            setTimeout(() => {
                                slowEffect.remove();
                            }, proj.slowDuration);
                        }
                        
                        if (proj.target.health <= 0) {
                            money += Math.round(proj.target.reward * difficultySettings[difficulty].rewardMultiplier);
                            gameStats.enemiesDefeated++;
                            gameStats.totalMoneyEarned += Math.round(proj.target.reward * difficultySettings[difficulty].rewardMultiplier);
                            if (proj.target.isGolem) {
                                gameStats.bossesDefeated++;
                            }
                            updateGameInfo();
                            removeEnemy(proj.target);
                            checkAchievements();
                            playSound('enemyDefeated');
                        }
                    }
                    
                    // ç§»é™¤æŠ•å°„ç‰©
                    proj.element.remove();
                    const projIndex = projectileElements.indexOf(proj.element);
                    if (projIndex !== -1) {
                        projectileElements.splice(projIndex, 1);
                    }
                    projectiles.splice(index, 1);
                } else {
                    // ç§»åŠ¨æŠ•å°„ç‰©
                    proj.x += (dx / distance) * 8;
                    proj.y += (dy / distance) * 8;
                    proj.element.style.left = `${proj.x-10}px`;
                    proj.element.style.top = `${proj.y-10}px`;
                }
            });
            
            // å¤„ç†ä¸­æ¯’æ•ˆæœ
            enemies.forEach(enemy => {
                if (enemy.poisoned && enemy.poisoned.timer > 0) {
                    enemy.poisoned.timer -= 16;
                    if (enemy.poisoned.timer % 1000 < 16) {
                        // æ¯ç§’é€ æˆä¸­æ¯’ä¼¤å®³
                        enemy.health -= enemy.poisoned.damage;
                        enemy.healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                        
                        // æ˜¾ç¤ºä¸­æ¯’ä¼¤å®³
                        const poisonDamage = document.createElement('div');
                        poisonDamage.textContent = `-${enemy.poisoned.damage}`;
                        poisonDamage.style.position = 'absolute';
                        poisonDamage.style.left = `${enemy.x-15}px`;
                        poisonDamage.style.top = `${enemy.y-30}px`;
                        poisonDamage.style.color = '#7cb342';
                        poisonDamage.style.fontWeight = 'bold';
                        document.getElementById('game-board').appendChild(poisonDamage);
                        
                        setTimeout(() => {
                            poisonDamage.style.top = `${enemy.y-50}px`;
                            poisonDamage.style.opacity = '0';
                            setTimeout(() => {
                                poisonDamage.remove();
                            }, 500);
                        }, 100);
                        
                        if (enemy.health <= 0) {
                            money += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                            gameStats.enemiesDefeated++;
                            gameStats.totalMoneyEarned += Math.round(enemy.reward * difficultySettings[difficulty].rewardMultiplier);
                            if (enemy.isGolem) {
                                gameStats.bossesDefeated++;
                            }
                            updateGameInfo();
                            removeEnemy(enemy);
                            checkAchievements();
                        }
                    }
                    
                    if (enemy.poisoned.timer <= 0) {
                        delete enemy.poisoned;
                    }
                }
                
                // å¤„ç†å‡é€Ÿæ•ˆæœ
                if (enemy.slowed && enemy.slowed.timer > 0 && !enemy.immuneToSlow) {
                    enemy.slowed.timer -= 16;
                    enemy.speed = enemy.originalSpeed * (1 - enemy.slowed.effect);
                    
                    if (enemy.slowed.timer <= 0) {
                        enemy.speed = enemy.originalSpeed;
                        delete enemy.slowed;
                    }
                }
            });
        }
        
        // åˆ›å»ºæŠ•å°„ç‰©
        function createProjectile(tower, enemy) {
            const projectile = {
                type: tower.type,
                x: tower.x,
                y: tower.y,
                target: enemy,
                damage: tower.damage,
                element: null,
                critChance: tower.critChance,
                stunDuration: tower.stunDuration,
                splashRadius: tower.splashRadius,
                // æ–°ç‚®å°ç‰¹æœ‰å±æ€§
                poisonChance: tower.poisonChance,
                poisonDuration: tower.poisonDuration,
                poisonDamage: tower.poisonDamage,
                pierceChance: tower.pierceChance,
                slowEffect: tower.slowEffect,
                slowDuration: tower.slowDuration,
                // è®°å½•æ–¹å‘ç”¨äºç©¿é€è®¡ç®—
                dx: enemy.x - tower.x,
                dy: enemy.y - tower.y
            };
            
            projectiles.push(projectile);
            
            // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæŠ•å°„ç‰©
            const projElement = document.createElement('div');
            projElement.className = 'projectile';
            
            // ä¸åŒå¡”æœ‰ä¸åŒçš„æŠ•å°„ç‰©å¤–è§‚
            switch(tower.type) {
                case 'pea-shooter':
                    projElement.textContent = 'â€¢';
                    projElement.style.color = '#2e7d32';
                    break;
                case 'pepper-thrower':
                    projElement.textContent = 'ğŸ”¥';
                    break;
                case 'onion-guard':
                    projElement.textContent = 'ğŸ’§';
                    projElement.style.color = '#ffeb3b';
                    break;
                case 'corn-cannon':
                    projElement.textContent = 'ğŸŒ½';
                    break;
                case 'garlic-tower':
                    projElement.textContent = 'ğŸ§„';
                    projElement.style.color = '#f8bbd0';
                    break;
                case 'cabbage-pult':
                    projElement.textContent = 'ğŸ¥¬';
                    projElement.style.color = '#dce775';
                    break;
                case 'melon-pult':
                    projElement.textContent = 'ğŸ‰';
                    break;
                case 'strawberry':
                    projElement.textContent = 'ğŸ“';
                    projElement.style.color = '#f44336';
                    break;
                case 'pineapple':
                    projElement.textContent = 'ğŸ';
                    projElement.style.color = '#ffeb3b';
                    break;
                case 'cactus':
                    projElement.textContent = 'ğŸŒµ';
                    projElement.style.color = '#4caf50';
                    break;
                case 'mushroom':
                    projElement.textContent = 'â˜ï¸';
                    projElement.style.color = '#7b1fa2';
                    break;
            }
            
            projElement.style.left = `${tower.x-10}px`;
            projElement.style.top = `${tower.y-10}px`;
            document.getElementById('game-board').appendChild(projElement);
            projectile.element = projElement;
            projectileElements.push(projElement);
        }
        
        // ç§»é™¤æ•Œäºº
        function removeEnemy(enemy) {
            enemy.element.remove();
            const index = enemies.indexOf(enemy);
            if (index !== -1) {
                enemies.splice(index, 1);
            }
            const elementIndex = enemyElements.indexOf(enemy.element);
            if (elementIndex !== -1) {
                enemyElements.splice(elementIndex, 1);
            }
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            clearInterval(window.gameLoop);
            window.gameLoop = null;
            if (sunflowerInterval) {
                clearInterval(sunflowerInterval);
                sunflowerInterval = null;
            }
            showMessage(`æ¸¸æˆç»“æŸ! ä½ åšæŒäº† ${wave} æ³¢`);
            document.getElementById('start-button').disabled = true;
            playSound('gameOver');
        }
        
        // æ›´æ–°æ¸¸æˆä¿¡æ¯
        function updateGameInfo() {
            document.getElementById('money').textContent = money;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = wave;
            document.getElementById('max-wave').textContent = maxWave;
            document.getElementById('achievement-count').textContent = gameStats.achievementsUnlocked;
            
            // æ›´æ–°é˜²å¾¡å¡”é€‰é¡¹çš„å¯è´­ä¹°çŠ¶æ€
            document.querySelectorAll('.tower-option').forEach(opt => {
                const type = opt.className.split(' ')[1];
                if (money < getTowerCost(type)) {
                    opt.style.opacity = '0.5';
                } else {
                    opt.style.opacity = '1';
                }
            });
        }
        
        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(type) {
            if (!soundEnabled) return;
            const sound = sounds[type];
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log('æ— æ³•æ’­æ”¾éŸ³æ•ˆ:', e));
            }
        }
        
        // æ£€æŸ¥æˆå°±
        function checkAchievements() {
            let newAchievements = false;
            let unlockedNewTower = false;
            
            achievementData.forEach(ach => {
                if (!achievements.includes(ach.id) && ach.condition(gameStats)) {
                    achievements.push(ach.id);
                    gameStats.achievementsUnlocked++;
                    showMessage(`æˆå°±è§£é”: ${ach.name}!`);
                    newAchievements = true;
                    
                    // è§£é”æ–°ç‚®å°
                    if (ach.unlockTower && !unlockedTowers[ach.unlockTower]) {
                        unlockedTowers[ach.unlockTower] = true;
                        unlockedNewTower = true;
                        
                        // æ˜¾ç¤ºè§£é”é€šçŸ¥
                        const unlockNotification = document.createElement('div');
                        unlockNotification.className = 'unlock-notification';
                        unlockNotification.textContent = `è§£é”æ–°ç‚®å°: ${towerData[ach.unlockTower].name} ${towerData[ach.unlockTower].emoji}`;
                        document.body.appendChild(unlockNotification);
                        
                        setTimeout(() => {
                            unlockNotification.remove();
                        }, 3000);
                        
                        playSound('unlock');
                    }
                    
                    // æ˜¾ç¤ºæˆå°±è§£é”æ•ˆæœ
                    const achievementUnlocked = document.createElement('div');
                    achievementUnlocked.className = 'special-wave';
                    achievementUnlocked.textContent = `æˆå°±è§£é”: ${ach.name}!`;
                    achievementUnlocked.style.backgroundColor = 'rgba(255, 215, 0, 0.8)';
                    document.getElementById('game-board').appendChild(achievementUnlocked);
                    
                    setTimeout(() => {
                        achievementUnlocked.remove();
                    }, 3000);
                }
            });
            
            if (newAchievements) {
                updateGameInfo();
                if (!unlockedNewTower) {
                    playSound('upgrade');
                }
            }
            
            if (unlockedNewTower) {
                updateTowerSelector();
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>